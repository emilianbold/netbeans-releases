/*  Prototype JavaScript framework, version 1.6.0.1
 *  (c) 2005-2007 Sam Stephenson
 *
 *  Prototype is freely distributable under the terms of an MIT-style license.
 *  For details, see the Prototype web site: http://www.prototypejs.org/
 *
 *--------------------------------------------------------------------------*/

var |>CLASS:Prototype<| = {
  Version: '1.6.0.1',

  Browser: {
    IE:     !!(|>GLOBAL:window<|.attachEvent && !|>GLOBAL:window<|.opera),
    Opera:  !!|>GLOBAL:window<|.opera,
    WebKit: |>GLOBAL:navigator<|.userAgent.indexOf('AppleWebKit/') > -1,
    Gecko:  |>GLOBAL:navigator<|.userAgent.indexOf('Gecko') > -1 && |>GLOBAL:navigator<|.userAgent.indexOf('KHTML') == -1,
    MobileSafari: !!|>GLOBAL:navigator<|.userAgent.match(|>REGEXP:/Apple.*Mobile.*Safari/<|)
  },

  BrowserFeatures: {
    XPath: !!|>GLOBAL:document<|.evaluate,
    ElementExtensions: !!|>GLOBAL:window<|.HTMLElement,
    SpecificElementExtensions:
      |>GLOBAL:document<|.createElement('div').__proto__ &&
      |>GLOBAL:document<|.createElement('div').__proto__ !==
        |>GLOBAL:document<|.createElement('form').__proto__
  },

  ScriptFragment: '<script[^>]*>([\\S\\s]*?)<\/script>',
  JSONFilter: |>REGEXP:/^\/\*-secure-([\s\S]*)\*\/\s*$/<|,

  |>METHOD:emptyFunction<|: function() { },
  |>METHOD:K<|: function(x) { return x }
};

if (|>CLASS:Prototype<|.Browser.MobileSafari)
  |>CLASS:Prototype<|.BrowserFeatures.SpecificElementExtensions = false;


/* Based on Alex Arnell's inheritance implementation. */
var |>CLASS:Class<| = {
  |>METHOD:create<|: function() {
    var parent = null, properties = $A(arguments);
    if (|>CLASS:Object<|.isFunction(properties[0]))
      parent = properties.shift();

    function |>METHOD:klass<|() {
      this.initialize.apply(this, arguments);
    }

    |>CLASS:Object<|.extend(|>GLOBAL:klass<|, |>CLASS:Class<|.Methods);
    |>GLOBAL:klass<|.superclass = parent;
    |>GLOBAL:klass<|.subclasses = [];

    if (parent) {
      var subclass = function() { };
      subclass.prototype = parent.prototype;
      |>GLOBAL:klass<|.prototype = new subclass;
      parent.subclasses.push(|>GLOBAL:klass<|);
    }

    for (var i = 0; i < properties.length; i++)
      |>GLOBAL:klass<|.addMethods(properties[i]);

    if (!|>GLOBAL:klass<|.prototype.initialize)
      |>GLOBAL:klass<|.prototype.initialize = |>CLASS:Prototype<|.emptyFunction;

    |>GLOBAL:klass<|.prototype.constructor = |>GLOBAL:klass<|;

    return |>GLOBAL:klass<|;
  }
};

|>CLASS:Class<|.Methods = {
  |>METHOD:addMethods<|: function(source) {
    var ancestor   = this.superclass && this.superclass.prototype;
    var properties = |>CLASS:Object<|.keys(source);

    if (!|>CLASS:Object<|.keys({ toString: true }).length)
      properties.push("toString", "valueOf");

    for (var i = 0, length = properties.length; i < length; i++) {
      var property = properties[i], value = source[property];
      if (ancestor && |>CLASS:Object<|.isFunction(value) &&
          value.argumentNames().first() == "$super") {
        var method = value, value = |>CLASS:Object<|.extend((function(m) {
          return function() { return ancestor[m].apply(this, arguments) };
        })(property).wrap(method), {
          |>METHOD:valueOf<|:  function() { return method },
          |>METHOD:toString<|: function() { return method.toString() }
        });
      }
      this.prototype[property] = value;
    }

    return this;
  }
};

var |>CLASS:Abstract<| = { };

|>CLASS:Object<|.extend = function(destination, source) {
  for (var property in source)
    destination[property] = source[property];
  return destination;
};

|>CLASS:Object<|.extend(|>CLASS:Object<|, {
  |>METHOD:inspect<|: function(object) {
    try {
      if (|>CLASS:Object<|.isUndefined(object)) return 'undefined';
      if (object === null) return 'null';
      return object.inspect ? object.inspect() : object.toString();
    } catch (e) {
      if (e instanceof |>CLASS:RangeError<|) return '...';
      throw e;
    }
  },

  |>METHOD:toJSON<|: function(object) {
    var type = typeof object;
    switch (type) {
      case 'undefined':
      case 'function':
      case 'unknown': return;
      case 'boolean': return object.toString();
    }

    if (object === null) return 'null';
    if (object.toJSON) return object.toJSON();
    if (|>CLASS:Object<|.isElement(object)) return;

    var results = [];
    for (var property in object) {
      var value = |>CLASS:Object<|.toJSON(object[property]);
      if (!|>CLASS:Object<|.isUndefined(value))
        results.push(property.toJSON() + ': ' + value);
    }

    return '{' + results.join(', ') + '}';
  },

  |>METHOD:toQueryString<|: function(object) {
    return $H(object).toQueryString();
  },

  |>METHOD:toHTML<|: function(object) {
    return object && object.toHTML ? object.toHTML() : |>CLASS:String<|.interpret(object);
  },

  |>METHOD:keys<|: function(object) {
    var keys = [];
    for (var property in object)
      keys.push(property);
    return keys;
  },

  |>METHOD:values<|: function(object) {
    var values = [];
    for (var property in object)
      values.push(object[property]);
    return values;
  },

  |>METHOD:clone<|: function(object) {
    return |>CLASS:Object<|.extend({ }, object);
  },

  |>METHOD:isElement<|: function(object) {
    return object && object.nodeType == 1;
  },

  |>METHOD:isArray<|: function(object) {
    return object && object.constructor === |>CLASS:Array<|;
  },

  |>METHOD:isHash<|: function(object) {
    return object instanceof |>CLASS:Hash<|;
  },

  |>METHOD:isFunction<|: function(|>UNUSED:object<|) {
    return typeof object == "function";
  },

  |>METHOD:isString<|: function(|>UNUSED:object<|) {
    return typeof object == "string";
  },

  |>METHOD:isNumber<|: function(|>UNUSED:object<|) {
    return typeof object == "number";
  },

  |>METHOD:isUndefined<|: function(|>UNUSED:object<|) {
    return typeof object == "undefined";
  }
});

|>CLASS:Object<|.extend(|>CLASS:Function<|.prototype, {
  |>METHOD:argumentNames<|: function() {
    var names = this.toString().match(|>REGEXP:/^[\s\(]*function[^(]*\((.*?)\)/<|)[1].split(",").invoke("strip");
    return names.length == 1 && !names[0] ? [] : names;
  },

  |>METHOD:bind<|: function() {
    if (arguments.length < 2 && |>CLASS:Object<|.isUndefined(arguments[0])) return this;
    var __method = this, args = $A(arguments), object = args.shift();
    return function() {
      return __method.apply(object, args.concat($A(arguments)));
    }
  },

  |>METHOD:bindAsEventListener<|: function() {
    var __method = this, args = $A(arguments), object = args.shift();
    return function(event) {
      return __method.apply(object, [event || |>GLOBAL:window<|.event].concat(args));
    }
  },

  |>METHOD:curry<|: function() {
    if (!arguments.length) return this;
    var __method = this, args = $A(arguments);
    return function() {
      return __method.apply(this, args.concat($A(arguments)));
    }
  },

  |>METHOD:delay<|: function() {
    var __method = this, args = $A(arguments), timeout = args.shift() * 1000;
    return |>GLOBAL:window<|.setTimeout(function() {
      return __method.apply(__method, args);
    }, timeout);
  },

  |>METHOD:wrap<|: function(wrapper) {
    var __method = this;
    return function() {
      return wrapper.apply(this, [__method.bind(this)].concat($A(arguments)));
    }
  },

  |>METHOD:methodize<|: function() {
    if (this._methodized) return this._methodized;
    var __method = this;
    return this._methodized = function() {
      return __method.apply(null, [this].concat($A(arguments)));
    };
  }
});

|>CLASS:Function<|.prototype.defer = |>CLASS:Function<|.prototype.delay.curry(0.01);

|>CLASS:Date<|.prototype.toJSON = function() {
  return '"' + this.getUTCFullYear() + '-' +
    (this.getUTCMonth() + 1).toPaddedString(2) + '-' +
    this.getUTCDate().toPaddedString(2) + 'T' +
    this.getUTCHours().toPaddedString(2) + ':' +
    this.getUTCMinutes().toPaddedString(2) + ':' +
    this.getUTCSeconds().toPaddedString(2) + 'Z"';
};

var |>CLASS:Try<| = {
  |>METHOD:these<|: function() {
    var returnValue;

    for (var i = 0, length = arguments.length; i < length; i++) {
      var lambda = arguments[i];
      try {
        returnValue = lambda();
        break;
      } catch (|>UNUSED:e<|) { }
    }

    return returnValue;
  }
};

|>CLASS:RegExp<|.prototype.match = |>CLASS:RegExp<|.prototype.test;

|>CLASS:RegExp<|.escape = function(str) {
  return String(str).replace(|>REGEXP:/([.*+?^=!:${}()|[\]\/\\])/g<|, '\\$1');
};

/*--------------------------------------------------------------------------*/

var |>CLASS:PeriodicalExecuter<| = |>CLASS:Class<|.create({
  |>METHOD:initialize<|: function(callback, frequency) {
    this.callback = callback;
    this.frequency = frequency;
    this.currentlyExecuting = false;

    this.registerCallback();
  },

  |>METHOD:registerCallback<|: function() {
    this.timer = setInterval(this.onTimerEvent.bind(this), this.frequency * 1000);
  },

  |>METHOD:execute<|: function() {
    this.callback(this);
  },

  |>METHOD:stop<|: function() {
    if (!this.timer) return;
    clearInterval(this.timer);
    this.timer = null;
  },

  |>METHOD:onTimerEvent<|: function() {
    if (!this.currentlyExecuting) {
      try {
        this.currentlyExecuting = true;
        this.execute();
      } finally {
        this.currentlyExecuting = false;
      }
    }
  }
});
|>CLASS:Object<|.extend(|>CLASS:String<|, {
  |>METHOD:interpret<|: function(value) {
    return value == null ? '' : String(value);
  },
  specialChar: {
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\f': '\\f',
    '\r': '\\r',
    '\\': '\\\\'
  }
});

|>CLASS:Object<|.extend(|>CLASS:String<|.prototype, {
  |>METHOD:gsub<|: function(pattern, replacement) {
    var result = '', source = this, match;
    replacement = arguments.callee.prepareReplacement(replacement);

    while (source.length > 0) {
      if (match = source.match(pattern)) {
        result += source.slice(0, match.index);
        result += |>CLASS:String<|.interpret(replacement(match));
        source  = source.slice(match.index + match[0].length);
      } else {
        result += source, source = '';
      }
    }
    return result;
  },

  |>METHOD:sub<|: function(pattern, replacement, count) {
    replacement = this.gsub.prepareReplacement(replacement);
    count = |>CLASS:Object<|.isUndefined(count) ? 1 : count;

    return this.gsub(pattern, function(match) {
      if (--count < 0) return match[0];
      return replacement(match);
    });
  },

  |>METHOD:scan<|: function(pattern, iterator) {
    this.gsub(pattern, iterator);
    return String(this);
  },

  |>METHOD:truncate<|: function(length, truncation) {
    length = length || 30;
    truncation = |>CLASS:Object<|.isUndefined(truncation) ? '...' : truncation;
    return this.length > length ?
      this.slice(0, length - truncation.length) + truncation : String(this);
  },

  |>METHOD:strip<|: function() {
    return this.replace(|>REGEXP:/^\s+/<|, '').replace(|>REGEXP:/\s+$/<|, '');
  },

  |>METHOD:stripTags<|: function() {
    return this.replace(|>REGEXP:/<\/?[^>]+>/gi<|, '');
  },

  |>METHOD:stripScripts<|: function() {
    return this.replace(new |>CLASS:RegExp<|(|>CLASS:Prototype<|.ScriptFragment, 'img'), '');
  },

  |>METHOD:extractScripts<|: function() {
    var matchAll = new |>CLASS:RegExp<|(|>CLASS:Prototype<|.ScriptFragment, 'img');
    var matchOne = new |>CLASS:RegExp<|(|>CLASS:Prototype<|.ScriptFragment, 'im');
    return (this.match(matchAll) || []).map(function(scriptTag) {
      return (scriptTag.match(matchOne) || ['', ''])[1];
    });
  },

  |>METHOD:evalScripts<|: function() {
    return this.extractScripts().map(function(script) { return eval(script) });
  },

  |>METHOD:escapeHTML<|: function() {
    var self = arguments.callee;
    self.text.data = this;
    return self.div.innerHTML;
  },

  |>METHOD:unescapeHTML<|: function() {
    var div = new |>CLASS:Element<|('div');
    div.innerHTML = this.stripTags();
    return div.childNodes[0] ? (div.childNodes.length > 1 ?
      $A(div.childNodes).inject('', function(memo, node) { return memo+node.nodeValue }) :
      div.childNodes[0].nodeValue) : '';
  },

  |>METHOD:toQueryParams<|: function(separator) {
    var match = this.strip().match(|>REGEXP:/([^?#]*)(#.*)?$/<|);
    if (!match) return { };

    return match[1].split(separator || '&').inject({ }, function(hash, pair) {
      if ((pair = pair.split('='))[0]) {
        var key = decodeURIComponent(pair.shift());
        var value = pair.length > 1 ? pair.join('=') : pair[0];
        if (value != undefined) value = decodeURIComponent(value);

        if (key in hash) {
          if (!|>CLASS:Object<|.isArray(hash[key])) hash[key] = [hash[key]];
          hash[key].push(value);
        }
        else hash[key] = value;
      }
      return hash;
    });
  },

  |>METHOD:toArray<|: function() {
    return this.split('');
  },

  |>METHOD:succ<|: function() {
    return this.slice(0, this.length - 1) +
      |>CLASS:String<|.fromCharCode(this.charCodeAt(this.length - 1) + 1);
  },

  |>METHOD:times<|: function(count) {
    return count < 1 ? '' : new |>CLASS:Array<|(count + 1).join(this);
  },

  |>METHOD:camelize<|: function() {
    var parts = this.split('-'), len = parts.length;
    if (len == 1) return parts[0];

    var camelized = this.charAt(0) == '-'
      ? parts[0].charAt(0).toUpperCase() + parts[0].substring(1)
      : parts[0];

    for (var i = 1; i < len; i++)
      camelized += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);

    return camelized;
  },

  |>METHOD:capitalize<|: function() {
    return this.charAt(0).toUpperCase() + this.substring(1).toLowerCase();
  },

  |>METHOD:underscore<|: function() {
    return this.gsub(|>REGEXP:/::/<|, '/').gsub(|>REGEXP:/([A-Z]+)([A-Z][a-z])/<|,'#{1}_#{2}').gsub(|>REGEXP:/([a-z\d])([A-Z])/<|,'#{1}_#{2}').gsub(|>REGEXP:/-/<|,'_').toLowerCase();
  },

  |>METHOD:dasherize<|: function() {
    return this.gsub(|>REGEXP:/_/<|,'-');
  },

  |>METHOD:inspect<|: function(useDoubleQuotes) {
    var escapedString = this.gsub(|>REGEXP:/[\x00-\x1f\\]/<|, function(match) {
      var character = |>CLASS:String<|.specialChar[match[0]];
      return character ? character : '\\u00' + match[0].charCodeAt().toPaddedString(2, 16);
    });
    if (useDoubleQuotes) return '"' + escapedString.replace(|>REGEXP:/"/g<|, '\\"') + '"';
    return "'" + escapedString.replace(|>REGEXP:/'/g<|, '\\\'') + "'";
  },

  |>METHOD:toJSON<|: function() {
    return this.inspect(true);
  },

  |>METHOD:unfilterJSON<|: function(filter) {
    return this.sub(filter || |>CLASS:Prototype<|.JSONFilter, '#{1}');
  },

  |>METHOD:isJSON<|: function() {
    var str = this;
    if (str.blank()) return false;
    str = this.replace(|>REGEXP:/\\./g<|, '@').replace(|>REGEXP:/"[^"\\\n\r]*"/g<|, '');
    return (|>REGEXP:/^[,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]*$/<|).test(str);
  },

  |>METHOD:evalJSON<|: function(sanitize) {
    var json = this.unfilterJSON();
    try {
      if (!sanitize || json.isJSON()) return eval('(' + json + ')');
    } catch (|>UNUSED:e<|) { }
    throw new |>CLASS:SyntaxError<|('Badly formed JSON string: ' + this.inspect());
  },

  |>METHOD:include<|: function(pattern) {
    return this.indexOf(pattern) > -1;
  },

  |>METHOD:startsWith<|: function(pattern) {
    return this.indexOf(pattern) === 0;
  },

  |>METHOD:endsWith<|: function(pattern) {
    var d = this.length - pattern.length;
    return d >= 0 && this.lastIndexOf(pattern) === d;
  },

  |>METHOD:empty<|: function() {
    return this == '';
  },

  |>METHOD:blank<|: function() {
    return |>REGEXP:/^\s*$/<|.test(this);
  },

  |>METHOD:interpolate<|: function(object, pattern) {
    return new |>CLASS:Template<|(this, pattern).evaluate(object);
  }
});

if (|>CLASS:Prototype<|.Browser.WebKit || |>CLASS:Prototype<|.Browser.IE) |>CLASS:Object<|.extend(|>CLASS:String<|.prototype, {
  |>METHOD:escapeHTML<|: function() {
    return this.replace(|>REGEXP:/&/g<|,'&amp;').replace(|>REGEXP:/</g<|,'&lt;').replace(|>REGEXP:/>/g<|,'&gt;');
  },
  |>METHOD:unescapeHTML<|: function() {
    return this.replace(|>REGEXP:/&amp;/g<|,'&').replace(|>REGEXP:/&lt;/g<|,'<').replace(|>REGEXP:/&gt;/g<|,'>');
  }
});

|>CLASS:String<|.prototype.gsub.prepareReplacement = function(replacement) {
  if (|>CLASS:Object<|.isFunction(replacement)) return replacement;
  var template = new |>CLASS:Template<|(replacement);
  return function(match) { return template.evaluate(match) };
};

|>CLASS:String<|.prototype.parseQuery = |>CLASS:String<|.prototype.toQueryParams;

|>CLASS:Object<|.extend(|>CLASS:String<|.prototype.escapeHTML, {
  div:  |>GLOBAL:document<|.createElement('div'),
  text: |>GLOBAL:document<|.createTextNode('')
});

with (|>CLASS:String<|.prototype.escapeHTML) div.appendChild(text);

var |>CLASS:Template<| = |>CLASS:Class<|.create({
  |>METHOD:initialize<|: function(template, pattern) {
    this.template = template.toString();
    this.pattern = pattern || |>CLASS:Template<|.Pattern;
  },

  |>METHOD:evaluate<|: function(object) {
    if (|>CLASS:Object<|.isFunction(object.toTemplateReplacements))
      object = object.toTemplateReplacements();

    return this.template.gsub(this.pattern, function(match) {
      if (object == null) return '';

      var before = match[1] || '';
      if (before == '\\') return match[2];

      var ctx = object, expr = match[3];
      var pattern = |>REGEXP:/^([^.[]+|\[((?:.*?[^\\])?)\])(\.|\[|$)/<|;
      match = pattern.exec(expr);
      if (match == null) return before;

      while (match != null) {
        var comp = match[1].startsWith('[') ? match[2].gsub('\\\\]', ']') : match[1];
        ctx = ctx[comp];
        if (null == ctx || '' == match[3]) break;
        expr = expr.substring('[' == match[3] ? match[1].length : match[0].length);
        match = pattern.exec(expr);
      }

      return before + |>CLASS:String<|.interpret(ctx);
    }.bind(this));
  }
});
|>CLASS:Template<|.Pattern = |>REGEXP:/(^|.|\r|\n)(#\{(.*?)\})/<|;

var |>GLOBAL:$break<| = { };

var |>CLASS:Enumerable<| = {
  |>METHOD:each<|: function(iterator, context) {
    var index = 0;
    iterator = iterator.bind(context);
    try {
      this._each(function(value) {
        iterator(value, index++);
      });
    } catch (e) {
      if (e != |>GLOBAL:$break<|) throw e;
    }
    return this;
  },

  |>METHOD:eachSlice<|: function(number, iterator, context) {
    iterator = iterator ? iterator.bind(context) : |>CLASS:Prototype<|.K;
    var index = -number, slices = [], array = this.toArray();
    while ((index += number) < array.length)
      slices.push(array.slice(index, index+number));
    return slices.collect(iterator, context);
  },

  |>METHOD:all<|: function(iterator, context) {
    iterator = iterator ? iterator.bind(context) : |>CLASS:Prototype<|.K;
    var result = true;
    this.each(function(value, index) {
      result = result && !!iterator(value, index);
      if (!result) throw |>GLOBAL:$break<|;
    });
    return result;
  },

  |>METHOD:any<|: function(iterator, context) {
    iterator = iterator ? iterator.bind(context) : |>CLASS:Prototype<|.K;
    var result = false;
    this.each(function(value, index) {
      if (result = !!iterator(value, index))
        throw |>GLOBAL:$break<|;
    });
    return result;
  },

  |>METHOD:collect<|: function(iterator, context) {
    iterator = iterator ? iterator.bind(context) : |>CLASS:Prototype<|.K;
    var results = [];
    this.each(function(value, index) {
      results.push(iterator(value, index));
    });
    return results;
  },

  |>METHOD:detect<|: function(iterator, context) {
    iterator = iterator.bind(context);
    var result;
    this.each(function(value, index) {
      if (iterator(value, index)) {
        result = value;
        throw |>GLOBAL:$break<|;
      }
    });
    return result;
  },

  |>METHOD:findAll<|: function(iterator, context) {
    iterator = iterator.bind(context);
    var results = [];
    this.each(function(value, index) {
      if (iterator(value, index))
        results.push(value);
    });
    return results;
  },

  |>METHOD:grep<|: function(filter, iterator, context) {
    iterator = iterator ? iterator.bind(context) : |>CLASS:Prototype<|.K;
    var results = [];

    if (|>CLASS:Object<|.isString(filter))
      filter = new |>CLASS:RegExp<|(filter);

    this.each(function(value, index) {
      if (filter.match(value))
        results.push(iterator(value, index));
    });
    return results;
  },

  |>METHOD:include<|: function(object) {
    if (|>CLASS:Object<|.isFunction(this.indexOf))
      if (this.indexOf(object) != -1) return true;

    var found = false;
    this.each(function(value) {
      if (value == object) {
        found = true;
        throw |>GLOBAL:$break<|;
      }
    });
    return found;
  },

  |>METHOD:inGroupsOf<|: function(number, fillWith) {
    fillWith = |>CLASS:Object<|.isUndefined(fillWith) ? null : fillWith;
    return this.eachSlice(number, function(slice) {
      while(slice.length < number) slice.push(fillWith);
      return slice;
    });
  },

  |>METHOD:inject<|: function(memo, iterator, context) {
    iterator = iterator.bind(context);
    this.each(function(value, index) {
      memo = iterator(memo, value, index);
    });
    return memo;
  },

  |>METHOD:invoke<|: function(method) {
    var args = $A(arguments).slice(1);
    return this.map(function(value) {
      return value[method].apply(value, args);
    });
  },

  |>METHOD:max<|: function(iterator, context) {
    iterator = iterator ? iterator.bind(context) : |>CLASS:Prototype<|.K;
    var result;
    this.each(function(value, index) {
      value = iterator(value, index);
      if (result == null || value >= result)
        result = value;
    });
    return result;
  },

  |>METHOD:min<|: function(iterator, context) {
    iterator = iterator ? iterator.bind(context) : |>CLASS:Prototype<|.K;
    var result;
    this.each(function(value, index) {
      value = iterator(value, index);
      if (result == null || value < result)
        result = value;
    });
    return result;
  },

  |>METHOD:partition<|: function(iterator, context) {
    iterator = iterator ? iterator.bind(context) : |>CLASS:Prototype<|.K;
    var trues = [], falses = [];
    this.each(function(value, index) {
      (iterator(value, index) ?
        trues : falses).push(value);
    });
    return [trues, falses];
  },

  |>METHOD:pluck<|: function(property) {
    var results = [];
    this.each(function(value) {
      results.push(value[property]);
    });
    return results;
  },

  |>METHOD:reject<|: function(iterator, context) {
    iterator = iterator.bind(context);
    var results = [];
    this.each(function(value, index) {
      if (!iterator(value, index))
        results.push(value);
    });
    return results;
  },

  |>METHOD:sortBy<|: function(iterator, context) {
    iterator = iterator.bind(context);
    return this.map(function(value, index) {
      return {value: value, criteria: iterator(value, index)};
    }).sort(function(left, right) {
      var a = left.criteria, b = right.criteria;
      return a < b ? -1 : a > b ? 1 : 0;
    }).pluck('value');
  },

  |>METHOD:toArray<|: function() {
    return this.map();
  },

  |>METHOD:zip<|: function() {
    var iterator = |>CLASS:Prototype<|.K, args = |>GLOBAL:$A<|(arguments);
    if (|>CLASS:Object<|.isFunction(args.last()))
      iterator = args.pop();

    var collections = [this].concat(args).map(|>GLOBAL:$A<|);
    return this.map(function(|>UNUSED:value<|, index) {
      return iterator(collections.pluck(index));
    });
  },

  |>METHOD:size<|: function() {
    return this.toArray().length;
  },

  |>METHOD:inspect<|: function() {
    return '#<Enumerable:' + this.toArray().inspect() + '>';
  }
};

|>CLASS:Object<|.extend(|>CLASS:Enumerable<|, {
  map:     |>CLASS:Enumerable<|.collect,
  find:    |>CLASS:Enumerable<|.detect,
  select:  |>CLASS:Enumerable<|.findAll,
  filter:  |>CLASS:Enumerable<|.findAll,
  member:  |>CLASS:Enumerable<|.include,
  entries: |>CLASS:Enumerable<|.toArray,
  every:   |>CLASS:Enumerable<|.all,
  some:    |>CLASS:Enumerable<|.any
});
function |>METHOD:$A<|(iterable) {
  if (!iterable) return [];
  if (iterable.toArray) return iterable.toArray();
  var length = iterable.length, results = new |>CLASS:Array<|(length);
  while (length--) results[length] = iterable[length];
  return results;
}

if (|>CLASS:Prototype<|.Browser.WebKit) {
  function |>METHOD:$A<|(iterable) {
    if (!iterable) return [];
    if (!(|>CLASS:Object<|.isFunction(iterable) && iterable == '[object NodeList]') &&
        iterable.toArray) return iterable.toArray();
    var length = iterable.length, results = new |>CLASS:Array<|(length);
    while (length--) results[length] = iterable[length];
    return results;
  }
}

|>CLASS:Array<|.from = |>GLOBAL:$A<|;

|>CLASS:Object<|.extend(|>CLASS:Array<|.prototype, |>CLASS:Enumerable<|);

if (!|>CLASS:Array<|.prototype._reverse) |>CLASS:Array<|.prototype._reverse = |>CLASS:Array<|.prototype.reverse;

|>CLASS:Object<|.extend(|>CLASS:Array<|.prototype, {
  |>METHOD:_each<|: function(iterator) {
    for (var i = 0, length = this.length; i < length; i++)
      iterator(this[i]);
  },

  |>METHOD:clear<|: function() {
    this.length = 0;
    return this;
  },

  |>METHOD:first<|: function() {
    return this[0];
  },

  |>METHOD:last<|: function() {
    return this[this.length - 1];
  },

  |>METHOD:compact<|: function() {
    return this.select(function(value) {
      return value != null;
    });
  },

  |>METHOD:flatten<|: function() {
    return this.inject([], function(array, value) {
      return array.concat(|>CLASS:Object<|.isArray(value) ?
        value.flatten() : [value]);
    });
  },

  |>METHOD:without<|: function() {
    var values = $A(arguments);
    return this.select(function(value) {
      return !values.include(value);
    });
  },

  |>METHOD:reverse<|: function(inline) {
    return (inline !== false ? this : this.toArray())._reverse();
  },

  |>METHOD:reduce<|: function() {
    return this.length > 1 ? this : this[0];
  },

  |>METHOD:uniq<|: function(sorted) {
    return this.inject([], function(array, value, index) {
      if (0 == index || (sorted ? array.last() != value : !array.include(value)))
        array.push(value);
      return array;
    });
  },

  |>METHOD:intersect<|: function(array) {
    return this.uniq().findAll(function(item) {
      return array.detect(function(value) { return item === value });
    });
  },

  |>METHOD:clone<|: function() {
    return [].concat(this);
  },

  |>METHOD:size<|: function() {
    return this.length;
  },

  |>METHOD:inspect<|: function() {
    return '[' + this.map(|>CLASS:Object<|.inspect).join(', ') + ']';
  },

  |>METHOD:toJSON<|: function() {
    var results = [];
    this.each(function(object) {
      var value = |>CLASS:Object<|.toJSON(object);
      if (!|>CLASS:Object<|.isUndefined(value)) results.push(value);
    });
    return '[' + results.join(', ') + ']';
  }
});

// use native browser JS 1.6 implementation if available
if (|>CLASS:Object<|.isFunction(|>CLASS:Array<|.prototype.forEach))
  |>CLASS:Array<|.prototype._each = |>CLASS:Array<|.prototype.forEach;

if (!|>CLASS:Array<|.prototype.indexOf) |>CLASS:Array<|.prototype.indexOf = function(item, i) {
  i || (i = 0);
  var length = this.length;
  if (i < 0) i = length + i;
  for (; i < length; i++)
    if (this[i] === item) return i;
  return -1;
};

if (!|>CLASS:Array<|.prototype.lastIndexOf) |>CLASS:Array<|.prototype.lastIndexOf = function(item, i) {
  i = isNaN(i) ? this.length : (i < 0 ? this.length + i : i) + 1;
  var n = this.slice(0, i).reverse().indexOf(item);
  return (n < 0) ? n : i - n - 1;
};

|>CLASS:Array<|.prototype.toArray = |>CLASS:Array<|.prototype.clone;

function |>METHOD:$w<|(string) {
  if (!|>CLASS:Object<|.isString(string)) return [];
  string = string.strip();
  return string ? string.split(|>REGEXP:/\s+/<|) : [];
}

if (|>CLASS:Prototype<|.Browser.Opera){
  |>CLASS:Array<|.prototype.concat = function() {
    var array = [];
    for (var i = 0, length = this.length; i < length; i++) array.push(this[i]);
    for (var i = 0, length = arguments.length; i < length; i++) {
      if (|>CLASS:Object<|.isArray(arguments[i])) {
        for (var j = 0, arrayLength = arguments[i].length; j < arrayLength; j++)
          array.push(arguments[i][j]);
      } else {
        array.push(arguments[i]);
      }
    }
    return array;
  };
}
|>CLASS:Object<|.extend(|>CLASS:Number<|.prototype, {
  |>METHOD:toColorPart<|: function() {
    return this.toPaddedString(2, 16);
  },

  |>METHOD:succ<|: function() {
    return this + 1;
  },

  |>METHOD:times<|: function(iterator) {
    $R(0, this, true).each(iterator);
    return this;
  },

  |>METHOD:toPaddedString<|: function(length, radix) {
    var string = this.toString(radix || 10);
    return '0'.times(length - string.length) + string;
  },

  |>METHOD:toJSON<|: function() {
    return isFinite(this) ? this.toString() : 'null';
  }
});

$w('abs round ceil floor').each(function(method){
  |>CLASS:Number<|.prototype[method] = |>CLASS:Math<|[method].methodize();
});
function |>METHOD:$H<|(object) {
  return new |>CLASS:Hash<|(object);
};

var |>CLASS:Hash<| = |>CLASS:Class<|.create(|>CLASS:Enumerable<|, (function() {

  function |>METHOD:toQueryPair<|(key, value) {
    if (|>CLASS:Object<|.isUndefined(value)) return key;
    return key + '=' + encodeURIComponent(|>CLASS:String<|.interpret(value));
  }

  return {
    |>METHOD:initialize<|: function(object) {
      this._object = |>CLASS:Object<|.isHash(object) ? object.toObject() : |>CLASS:Object<|.clone(object);
    },

    |>METHOD:_each<|: function(iterator) {
      for (var key in this._object) {
        var value = this._object[key], pair = [key, value];
        pair.key = key;
        pair.value = value;
        iterator(pair);
      }
    },

    |>METHOD:set<|: function(key, value) {
      return this._object[key] = value;
    },

    |>METHOD:get<|: function(key) {
      return this._object[key];
    },

    |>METHOD:unset<|: function(key) {
      var value = this._object[key];
      delete this._object[key];
      return value;
    },

    |>METHOD:toObject<|: function() {
      return |>CLASS:Object<|.clone(this._object);
    },

    |>METHOD:keys<|: function() {
      return this.pluck('key');
    },

    |>METHOD:values<|: function() {
      return this.pluck('value');
    },

    |>METHOD:index<|: function(value) {
      var match = this.detect(function(pair) {
        return pair.value === value;
      });
      return match && match.key;
    },

    |>METHOD:merge<|: function(object) {
      return this.clone().update(object);
    },

    |>METHOD:update<|: function(object) {
      return new |>CLASS:Hash<|(object).inject(this, function(result, pair) {
        result.set(pair.key, pair.value);
        return result;
      });
    },

    |>METHOD:toQueryString<|: function() {
      return this.map(function(pair) {
        var key = encodeURIComponent(pair.key), values = pair.value;

        if (values && typeof values == 'object') {
          if (|>CLASS:Object<|.isArray(values))
            return values.map(|>GLOBAL:toQueryPair<|.curry(key)).join('&');
        }
        return |>GLOBAL:toQueryPair<|(key, values);
      }).join('&');
    },

    |>METHOD:inspect<|: function() {
      return '#<Hash:{' + this.map(function(pair) {
        return pair.map(|>CLASS:Object<|.inspect).join(': ');
      }).join(', ') + '}>';
    },

    |>METHOD:toJSON<|: function() {
      return |>CLASS:Object<|.toJSON(this.toObject());
    },

    |>METHOD:clone<|: function() {
      return new |>CLASS:Hash<|(this);
    }
  }
})());

|>CLASS:Hash<|.prototype.toTemplateReplacements = |>CLASS:Hash<|.prototype.toObject;
|>CLASS:Hash<|.from = |>GLOBAL:$H<|;
var |>CLASS:ObjectRange<| = |>CLASS:Class<|.create(|>CLASS:Enumerable<|, {
  |>METHOD:initialize<|: function(start, end, exclusive) {
    this.start = start;
    this.end = end;
    this.exclusive = exclusive;
  },

  |>METHOD:_each<|: function(iterator) {
    var value = this.start;
    while (this.include(value)) {
      iterator(value);
      value = value.succ();
    }
  },

  |>METHOD:include<|: function(value) {
    if (value < this.start)
      return false;
    if (this.exclusive)
      return value < this.end;
    return value <= this.end;
  }
});

var |>GLOBAL:$R<| = function(start, end, exclusive) {
  return new |>CLASS:ObjectRange<|(start, end, exclusive);
};

var |>CLASS:Ajax<| = {
  |>METHOD:getTransport<|: function() {
    return |>CLASS:Try<|.these(
      function() {return new |>CLASS:XMLHttpRequest<|()},
      function() {return new |>CLASS:ActiveXObject<|('Msxml2.XMLHTTP')},
      function() {return new |>CLASS:ActiveXObject<|('Microsoft.XMLHTTP')}
    ) || false;
  },

  activeRequestCount: 0
};

|>CLASS:Ajax<|.Responders = {
  responders: [],

  |>METHOD:_each<|: function(iterator) {
    this.responders._each(iterator);
  },

  |>METHOD:register<|: function(responder) {
    if (!this.include(responder))
      this.responders.push(responder);
  },

  |>METHOD:unregister<|: function(responder) {
    this.responders = this.responders.without(responder);
  },

  |>METHOD:dispatch<|: function(callback, request, transport, json) {
    this.each(function(responder) {
      if (|>CLASS:Object<|.isFunction(responder[callback])) {
        try {
          responder[callback].apply(responder, [request, transport, json]);
        } catch (|>UNUSED:e<|) { }
      }
    });
  }
};

|>CLASS:Object<|.extend(|>CLASS:Ajax<|.Responders, |>CLASS:Enumerable<|);

|>CLASS:Ajax<|.Responders.register({
  |>METHOD:onCreate<|:   function() { |>CLASS:Ajax<|.activeRequestCount++ },
  |>METHOD:onComplete<|: function() { |>CLASS:Ajax<|.activeRequestCount-- }
});

|>CLASS:Ajax<|.Base = |>CLASS:Class<|.create({
  |>METHOD:initialize<|: function(options) {
    this.options = {
      method:       'post',
      asynchronous: true,
      contentType:  'application/x-www-form-urlencoded',
      encoding:     'UTF-8',
      parameters:   '',
      evalJSON:     true,
      evalJS:       true
    };
    |>CLASS:Object<|.extend(this.options, options || { });

    this.options.method = this.options.method.toLowerCase();

    if (|>CLASS:Object<|.isString(this.options.parameters))
      this.options.parameters = this.options.parameters.toQueryParams();
    else if (|>CLASS:Object<|.isHash(this.options.parameters))
      this.options.parameters = this.options.parameters.toObject();
  }
});

|>CLASS:Ajax<|.Request = |>CLASS:Class<|.create(|>CLASS:Ajax<|.Base, {
  _complete: false,

  |>METHOD:initialize<|: function($super, url, options) {
    $super(options);
    this.transport = |>CLASS:Ajax<|.getTransport();
    this.request(url);
  },

  |>METHOD:request<|: function(url) {
    this.url = url;
    this.method = this.options.method;
    var params = |>CLASS:Object<|.clone(this.options.parameters);

    if (!['get', 'post'].include(this.method)) {
      // simulate other verbs over post
      params['_method'] = this.method;
      this.method = 'post';
    }

    this.parameters = params;

    if (params = |>CLASS:Object<|.toQueryString(params)) {
      // when GET, append parameters to URL
      if (this.method == 'get')
        this.url += (this.url.include('?') ? '&' : '?') + params;
      else if (|>REGEXP:/Konqueror|Safari|KHTML/<|.test(|>GLOBAL:navigator<|.userAgent))
        params += '&_=';
    }

    try {
      var response = new |>CLASS:Ajax<|.Response(this);
      if (this.options.onCreate) this.options.onCreate(response);
      |>CLASS:Ajax<|.Responders.dispatch('onCreate', this, response);

      this.transport.open(this.method.toUpperCase(), this.url,
        this.options.asynchronous);

      if (this.options.asynchronous) this.respondToReadyState.bind(this).defer(1);

      this.transport.onreadystatechange = this.onStateChange.bind(this);
      this.setRequestHeaders();

      this.body = this.method == 'post' ? (this.options.postBody || params) : null;
      this.transport.send(this.body);

      /* Force Firefox to handle ready state 4 for synchronous requests */
      if (!this.options.asynchronous && this.transport.overrideMimeType)
        this.onStateChange();

    }
    catch (e) {
      this.dispatchException(e);
    }
  },

  |>METHOD:onStateChange<|: function() {
    var readyState = this.transport.readyState;
    if (readyState > 1 && !((readyState == 4) && this._complete))
      this.respondToReadyState(this.transport.readyState);
  },

  |>METHOD:setRequestHeaders<|: function() {
    var headers = {
      'X-Requested-With': 'XMLHttpRequest',
      'X-Prototype-Version': |>CLASS:Prototype<|.Version,
      'Accept': 'text/javascript, text/html, application/xml, text/xml, */*'
    };

    if (this.method == 'post') {
      headers['Content-type'] = this.options.contentType +
        (this.options.encoding ? '; charset=' + this.options.encoding : '');

      /* Force "Connection: close" for older Mozilla browsers to work
       * around a bug where XMLHttpRequest sends an incorrect
       * Content-length header. See Mozilla Bugzilla #246651.
       */
      if (this.transport.overrideMimeType &&
          (|>GLOBAL:navigator<|.userAgent.match(|>REGEXP:/Gecko\/(\d{4})/<|) || [0,2005])[1] < 2005)
            headers['Connection'] = 'close';
    }

    // user-defined headers
    if (typeof this.options.requestHeaders == 'object') {
      var extras = this.options.requestHeaders;

      if (|>CLASS:Object<|.isFunction(extras.push))
        for (var i = 0, length = extras.length; i < length; i += 2)
          headers[extras[i]] = extras[i+1];
      else
        $H(extras).each(function(pair) { headers[pair.key] = pair.value });
    }

    for (var name in headers)
      this.transport.setRequestHeader(name, headers[name]);
  },

  |>METHOD:success<|: function() {
    var status = this.getStatus();
    return !status || (status >= 200 && status < 300);
  },

  |>METHOD:getStatus<|: function() {
    try {
      return this.transport.status || 0;
    } catch (|>UNUSED:e<|) { return 0 }
  },

  |>METHOD:respondToReadyState<|: function(readyState) {
    var state = |>CLASS:Ajax<|.Request.Events[readyState], response = new |>CLASS:Ajax<|.Response(this);

    if (state == 'Complete') {
      try {
        this._complete = true;
        (this.options['on' + response.status]
         || this.options['on' + (this.success() ? 'Success' : 'Failure')]
         || |>CLASS:Prototype<|.emptyFunction)(response, response.headerJSON);
      } catch (e) {
        this.dispatchException(e);
      }

      var contentType = response.getHeader('Content-type');
      if (this.options.evalJS == 'force'
          || (this.options.evalJS && contentType
          && contentType.match(|>REGEXP:/^\s*(text|application)\/(x-)?(java|ecma)script(;.*)?\s*$/i<|)))
        this.evalResponse();
    }

    try {
      (this.options['on' + state] || |>CLASS:Prototype<|.emptyFunction)(response, response.headerJSON);
      |>CLASS:Ajax<|.Responders.dispatch('on' + state, this, response, response.headerJSON);
    } catch (e) {
      this.dispatchException(e);
    }

    if (state == 'Complete') {
      // avoid memory leak in MSIE: clean up
      this.transport.onreadystatechange = |>CLASS:Prototype<|.emptyFunction;
    }
  },

  |>METHOD:getHeader<|: function(name) {
    try {
      return this.transport.getResponseHeader(name);
    } catch (|>UNUSED:e<|) { return null }
  },

  |>METHOD:evalResponse<|: function() {
    try {
      return eval((this.transport.responseText || '').unfilterJSON());
    } catch (e) {
      this.dispatchException(e);
    }
  },

  |>METHOD:dispatchException<|: function(exception) {
    (this.options.onException || |>CLASS:Prototype<|.emptyFunction)(this, exception);
    |>CLASS:Ajax<|.Responders.dispatch('onException', this, exception);
  }
});

|>CLASS:Ajax<|.Request.Events =
  ['Uninitialized', 'Loading', 'Loaded', 'Interactive', 'Complete'];

|>CLASS:Ajax<|.Response = |>CLASS:Class<|.create({
  |>METHOD:initialize<|: function(request){
    this.request = request;
    var transport  = this.transport  = request.transport,
        readyState = this.readyState = transport.readyState;

    if((readyState > 2 && !|>CLASS:Prototype<|.Browser.IE) || readyState == 4) {
      this.status       = this.getStatus();
      this.statusText   = this.getStatusText();
      this.responseText = |>CLASS:String<|.interpret(transport.responseText);
      this.headerJSON   = this._getHeaderJSON();
    }

    if(readyState == 4) {
      var xml = transport.responseXML;
      this.responseXML  = |>CLASS:Object<|.isUndefined(xml) ? null : xml;
      this.responseJSON = this._getResponseJSON();
    }
  },

  status:      0,
  statusText: '',

  getStatus: |>CLASS:Ajax<|.Request.prototype.getStatus,

  |>METHOD:getStatusText<|: function() {
    try {
      return this.transport.statusText || '';
    } catch (|>UNUSED:e<|) { return '' }
  },

  getHeader: |>CLASS:Ajax<|.Request.prototype.getHeader,

  |>METHOD:getAllHeaders<|: function() {
    try {
      return this.getAllResponseHeaders();
    } catch (|>UNUSED:e<|) { return null }
  },

  |>METHOD:getResponseHeader<|: function(name) {
    return this.transport.getResponseHeader(name);
  },

  |>METHOD:getAllResponseHeaders<|: function() {
    return this.transport.getAllResponseHeaders();
  },

  |>METHOD:_getHeaderJSON<|: function() {
    var json = this.getHeader('X-JSON');
    if (!json) return null;
    json = decodeURIComponent(escape(json));
    try {
      return json.evalJSON(this.request.options.sanitizeJSON);
    } catch (e) {
      this.request.dispatchException(e);
    }
  },

  |>METHOD:_getResponseJSON<|: function() {
    var options = this.request.options;
    if (!options.evalJSON || (options.evalJSON != 'force' &&
      !(this.getHeader('Content-type') || '').include('application/json')) ||
        this.responseText.blank())
          return null;
    try {
      return this.responseText.evalJSON(options.sanitizeJSON);
    } catch (e) {
      this.request.dispatchException(e);
    }
  }
});

|>CLASS:Ajax<|.Updater = |>CLASS:Class<|.create(|>CLASS:Ajax<|.Request, {
  |>METHOD:initialize<|: function($super, container, url, options) {
    this.container = {
      success: (container.success || container),
      failure: (container.failure || (container.success ? null : container))
    };

    options = |>CLASS:Object<|.clone(options);
    var onComplete = options.onComplete;
    options.onComplete = (function(response, json) {
      this.updateContent(response.responseText);
      if (|>CLASS:Object<|.isFunction(onComplete)) onComplete(response, json);
    }).bind(this);

    $super(url, options);
  },

  |>METHOD:updateContent<|: function(responseText) {
    var receiver = this.container[this.success() ? 'success' : 'failure'],
        options = this.options;

    if (!options.evalScripts) responseText = responseText.stripScripts();

    if (receiver = $(receiver)) {
      if (options.insertion) {
        if (|>CLASS:Object<|.isString(options.insertion)) {
          var insertion = { }; insertion[options.insertion] = responseText;
          receiver.insert(insertion);
        }
        else options.insertion(receiver, responseText);
      }
      else receiver.update(responseText);
    }
  }
});

|>CLASS:Ajax<|.PeriodicalUpdater = |>CLASS:Class<|.create(|>CLASS:Ajax<|.Base, {
  |>METHOD:initialize<|: function($super, container, url, options) {
    $super(options);
    this.onComplete = this.options.onComplete;

    this.frequency = (this.options.frequency || 2);
    this.decay = (this.options.decay || 1);

    this.updater = { };
    this.container = container;
    this.url = url;

    this.start();
  },

  |>METHOD:start<|: function() {
    this.options.onComplete = this.updateComplete.bind(this);
    this.onTimerEvent();
  },

  |>METHOD:stop<|: function() {
    this.updater.options.onComplete = undefined;
    clearTimeout(this.timer);
    (this.onComplete || |>CLASS:Prototype<|.emptyFunction).apply(this, arguments);
  },

  |>METHOD:updateComplete<|: function(response) {
    if (this.options.decay) {
      this.decay = (response.responseText == this.lastText ?
        this.decay * this.options.decay : 1);

      this.lastText = response.responseText;
    }
    this.timer = this.onTimerEvent.bind(this).delay(this.decay * this.frequency);
  },

  |>METHOD:onTimerEvent<|: function() {
    this.updater = new |>CLASS:Ajax<|.Updater(this.container, this.url, this.options);
  }
});
function |>METHOD:$<|(element) {
  if (arguments.length > 1) {
    for (var i = 0, elements = [], length = arguments.length; i < length; i++)
      elements.push($(arguments[i]));
    return elements;
  }
  if (|>CLASS:Object<|.isString(element))
    element = |>GLOBAL:document<|.getElementById(element);
  return |>CLASS:Element<|.extend(element);
}

if (|>CLASS:Prototype<|.BrowserFeatures.XPath) {
  |>GLOBAL:document<|._getElementsByXPath = function(expression, parentElement) {
    var results = [];
    var query = |>GLOBAL:document<|.evaluate(expression, $(parentElement) || |>GLOBAL:document<|,
      null, |>CLASS:XPathResult<|.ORDERED_NODE_SNAPSHOT_TYPE, null);
    for (var i = 0, length = query.snapshotLength; i < length; i++)
      results.push(|>CLASS:Element<|.extend(query.snapshotItem(i)));
    return results;
  };
}

/*--------------------------------------------------------------------------*/

if (!|>GLOBAL:window<|.Node) var |>CLASS:Node<| = { };

if (!|>CLASS:Node<|.ELEMENT_NODE) {
  // DOM level 2 ECMAScript Language Binding
  |>CLASS:Object<|.extend(|>CLASS:Node<|, {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    ENTITY_REFERENCE_NODE: 5,
    ENTITY_NODE: 6,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
    NOTATION_NODE: 12
  });
}

(function() {
  var element = this.Element;
  this.Element = function(tagName, attributes) {
    attributes = attributes || { };
    tagName = tagName.toLowerCase();
    var cache = |>CLASS:Element<|.cache;
    if (|>CLASS:Prototype<|.Browser.IE && attributes.name) {
      tagName = '<' + tagName + ' name="' + attributes.name + '">';
      delete attributes.name;
      return |>CLASS:Element<|.writeAttribute(|>GLOBAL:document<|.createElement(tagName), attributes);
    }
    if (!cache[tagName]) cache[tagName] = |>CLASS:Element<|.extend(|>GLOBAL:document<|.createElement(tagName));
    return |>CLASS:Element<|.writeAttribute(cache[tagName].cloneNode(false), attributes);
  };
  |>CLASS:Object<|.extend(this.Element, element || { });
}).call(|>GLOBAL:window<|);

|>CLASS:Element<|.cache = { };

|>CLASS:Element<|.Methods = {
  |>METHOD:visible<|: function(element) {
    return $(element).style.display != 'none';
  },

  |>METHOD:toggle<|: function(element) {
    element = $(element);
    |>CLASS:Element<|[|>CLASS:Element<|.visible(element) ? 'hide' : 'show'](element);
    return element;
  },

  |>METHOD:hide<|: function(element) {
    $(element).style.display = 'none';
    return element;
  },

  |>METHOD:show<|: function(element) {
    $(element).style.display = '';
    return element;
  },

  |>METHOD:remove<|: function(element) {
    element = $(element);
    element.parentNode.removeChild(element);
    return element;
  },

  |>METHOD:update<|: function(element, content) {
    element = $(element);
    if (content && content.toElement) content = content.toElement();
    if (|>CLASS:Object<|.isElement(content)) return element.update().insert(content);
    content = |>CLASS:Object<|.toHTML(content);
    element.innerHTML = content.stripScripts();
    content.evalScripts.bind(content).defer();
    return element;
  },

  |>METHOD:replace<|: function(element, content) {
    element = $(element);
    if (content && content.toElement) content = content.toElement();
    else if (!|>CLASS:Object<|.isElement(content)) {
      content = |>CLASS:Object<|.toHTML(content);
      var range = element.ownerDocument.createRange();
      range.selectNode(element);
      content.evalScripts.bind(content).defer();
      content = range.createContextualFragment(content.stripScripts());
    }
    element.parentNode.replaceChild(content, element);
    return element;
  },

  |>METHOD:compileMatcher<|: function() {
    if (this.shouldUseXPath())
      return this.compileXPathMatcher();

    var e = this.expression, ps = |>CLASS:Selector<|.patterns, |>UNUSED:h<| = |>CLASS:Selector<|.handlers,
        c = |>CLASS:Selector<|.criteria, le, p, m;

    if (|>CLASS:Selector<|._cache[e]) {
      this.matcher = |>CLASS:Selector<|._cache[e];
      return;
    }

    this.matcher = ["this.matcher = function(root) {",
                    "var r = root, h = Selector.handlers, c = false, n;"];

    while (e && le != e && (|>REGEXP:/\S/<|).test(e)) {
      le = e;
      for (var i in ps) {
        p = ps[i];
        if (m = e.match(p)) {
          this.matcher.push(|>CLASS:Object<|.isFunction(c[i]) ? c[i](m) :
    	      new |>CLASS:Template<|(c[i]).evaluate(m));
          e = e.replace(m[0], '');
          break;
        }
      }
    }

    this.matcher.push("return h.unique(n);\n}");
    eval(this.matcher.join('\n'));
    |>CLASS:Selector<|._cache[this.expression] = this.matcher;
  },
  |>METHOD:removeClassName<|: function(element, className) {
    if (!(element = $(element))) return;
    element.className = element.className.replace(
      new |>CLASS:RegExp<|("(^|\\s+)" + className + "(\\s+|$)"), ' ').strip();
    return element;
  },

  
  |>METHOD:insert<|: function(element, insertions) {
    element = $(element);

    if (|>CLASS:Object<|.isString(insertions) || |>CLASS:Object<|.isNumber(insertions) ||
        |>CLASS:Object<|.isElement(insertions) || (insertions && (insertions.toElement || insertions.toHTML)))
          insertions = {bottom:insertions};

    var content, t, range;

    for (|>GLOBAL:position<| in insertions) {
      content  = insertions[|>GLOBAL:position<|];
      |>GLOBAL:position<| = |>GLOBAL:position<|.toLowerCase();
      t = |>CLASS:Element<|._insertionTranslations[|>GLOBAL:position<|];

      if (content && content.toElement) content = content.toElement();
      if (|>CLASS:Object<|.isElement(content)) {
        t.insert(element, content);
        continue;
      }

      content = |>CLASS:Object<|.toHTML(content);

      range = element.ownerDocument.createRange();
      t.initializeRange(element, range);
      t.insert(element, range.createContextualFragment(content.stripScripts()));

      content.evalScripts.bind(content).defer();
    }

    return element;
  },

  |>METHOD:wrap<|: function(element, wrapper, attributes) {
    element = $(element);
    if (|>CLASS:Object<|.isElement(wrapper))
      $(wrapper).writeAttribute(attributes || { });
    else if (|>CLASS:Object<|.isString(wrapper)) wrapper = new |>CLASS:Element<|(wrapper, attributes);
    else wrapper = new |>CLASS:Element<|('div', wrapper);
    if (element.parentNode)
      element.parentNode.replaceChild(wrapper, element);
    wrapper.appendChild(element);
    return wrapper;
  },

  |>METHOD:inspect<|: function(element) {
    element = $(element);
    var result = '<' + element.tagName.toLowerCase();
    $H({'id': 'id', 'className': 'class'}).each(function(pair) {
      var property = pair.first(), attribute = pair.last();
      var value = (element[property] || '').toString();
      if (value) result += ' ' + attribute + '=' + value.inspect(true);
    });
    return result + '>';
  },

  |>METHOD:recursivelyCollect<|: function(element, property) {
    element = $(element);
    var elements = [];
    while (element = element[property])
      if (element.nodeType == 1)
        elements.push(|>CLASS:Element<|.extend(element));
    return elements;
  },

  |>METHOD:ancestors<|: function(element) {
    return $(element).recursivelyCollect('parentNode');
  },

  |>METHOD:descendants<|: function(element) {
    return $(element).getElementsBySelector("*");
  },

  |>METHOD:firstDescendant<|: function(element) {
    element = $(element).firstChild;
    while (element && element.nodeType != 1) element = element.nextSibling;
    return $(element);
  },

  |>METHOD:immediateDescendants<|: function(element) {
    if (!(element = $(element).firstChild)) return [];
    while (element && element.nodeType != 1) element = element.nextSibling;
    if (element) return [element].concat($(element).nextSiblings());
    return [];
  },

  |>METHOD:previousSiblings<|: function(element) {
    return $(element).recursivelyCollect('previousSibling');
  },

  |>METHOD:nextSiblings<|: function(element) {
    return $(element).recursivelyCollect('nextSibling');
  },

  |>METHOD:siblings<|: function(element) {
    element = $(element);
    return element.previousSiblings().reverse().concat(element.nextSiblings());
  },

  |>METHOD:match<|: function(element, selector) {
    if (|>CLASS:Object<|.isString(selector))
      selector = new |>CLASS:Selector<|(selector);
    return selector.match($(element));
  },

  |>METHOD:up<|: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(element.parentNode);
    var ancestors = element.ancestors();
    return expression ? |>CLASS:Selector<|.findElement(ancestors, expression, index) :
      ancestors[index || 0];
  },

  |>METHOD:down<|: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return element.firstDescendant();
    var descendants = element.descendants();
    return expression ? |>CLASS:Selector<|.findElement(descendants, expression, index) :
      descendants[index || 0];
  },

  |>METHOD:previous<|: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(|>CLASS:Selector<|.handlers.previousElementSibling(element));
    var previousSiblings = element.previousSiblings();
    return expression ? |>CLASS:Selector<|.findElement(previousSiblings, expression, index) :
      previousSiblings[index || 0];
  },

  |>METHOD:next<|: function(element, expression, index) {
    element = $(element);
    if (arguments.length == 1) return $(|>CLASS:Selector<|.handlers.nextElementSibling(element));
    var nextSiblings = element.nextSiblings();
    return expression ? |>CLASS:Selector<|.findElement(nextSiblings, expression, index) :
      nextSiblings[index || 0];
  },

  |>METHOD:select<|: function() {
    var args = $A(arguments), element = $(args.shift());
    return |>CLASS:Selector<|.findChildElements(element, args);
  },

  |>METHOD:adjacent<|: function() {
    var args = $A(arguments), element = $(args.shift());
    return |>CLASS:Selector<|.findChildElements(element.parentNode, args).without(element);
  },

  |>METHOD:identify<|: function(element) {
    element = $(element);
    var id = element.readAttribute('id'), self = arguments.callee;
    if (id) return id;
    do { id = 'anonymous_element_' + self.counter++ } while ($(id));
    element.writeAttribute('id', id);
    return id;
  },

  |>METHOD:readAttribute<|: function(element, name) {
    element = $(element);
    if (|>CLASS:Prototype<|.Browser.IE) {
      var t = |>CLASS:Element<|._attributeTranslations.read;
      if (t.values[name]) return t.values[name](element, name);
      if (t.names[name]) name = t.names[name];
      if (name.include(':')) {
        return (!element.attributes || !element.attributes[name]) ? null :
         element.attributes[name].value;
      }
    }
    return element.getAttribute(name);
  },

  |>METHOD:writeAttribute<|: function(element, name, value) {
    element = $(element);
    var attributes = { }, t = |>CLASS:Element<|._attributeTranslations.write;

    if (typeof name == 'object') attributes = name;
    else attributes[name] = |>CLASS:Object<|.isUndefined(value) ? true : value;

    for (var attr in attributes) {
      name = t.names[attr] || attr;
      value = attributes[attr];
      if (t.values[attr]) name = t.values[attr](element, value);
      if (value === false || value === null)
        element.removeAttribute(name);
      else if (value === true)
        element.setAttribute(name, name);
      else element.setAttribute(name, value);
    }
    return element;
  },

  |>METHOD:getHeight<|: function(element) {
    return $(element).getDimensions().height;
  },

  |>METHOD:getWidth<|: function(element) {
    return $(element).getDimensions().width;
  },

  |>METHOD:classNames<|: function(element) {
    return new |>CLASS:Element<|.ClassNames(element);
  },

  |>METHOD:hasClassName<|: function(element, className) {
    if (!(element = $(element))) return;
    var elementClassName = element.className;
    return (elementClassName.length > 0 && (elementClassName == className ||
      new |>CLASS:RegExp<|("(^|\\s)" + className + "(\\s|$)").test(elementClassName)));
  },

  |>METHOD:addClassName<|: function(element, className) {
    if (!(element = $(element))) return;
    if (!element.hasClassName(className))
      element.className += (element.className ? ' ' : '') + className;
    return element;
  },

  |>METHOD:removeClassName<|: function(element, className) {
    if (!(element = $(element))) return;
    element.className = element.className.replace(
      new |>CLASS:RegExp<|("(^|\\s+)" + className + "(\\s+|$)"), ' ').strip();
    return element;
  },

  |>METHOD:toggleClassName<|: function(element, className) {
    if (!(element = $(element))) return;
    return element[element.hasClassName(className) ?
      'removeClassName' : 'addClassName'](className);
  },

  // removes whitespace-only text node children
  |>METHOD:cleanWhitespace<|: function(element) {
    element = $(element);
    var node = element.firstChild;
    while (node) {
      var nextNode = node.nextSibling;
      if (node.nodeType == 3 && !|>REGEXP:/\S/<|.test(node.nodeValue))
        element.removeChild(node);
      node = nextNode;
    }
    return element;
  },

  |>METHOD:empty<|: function(element) {
    return $(element).innerHTML.blank();
  },

  |>METHOD:descendantOf<|: function(element, ancestor) {
    element = $(element), ancestor = $(ancestor);
    var originalAncestor = ancestor;

    if (element.compareDocumentPosition)
      return (element.compareDocumentPosition(ancestor) & 8) === 8;

    if (element.sourceIndex && !|>CLASS:Prototype<|.Browser.Opera) {
      var e = element.sourceIndex, a = ancestor.sourceIndex,
       nextAncestor = ancestor.nextSibling;
      if (!nextAncestor) {
        do { ancestor = ancestor.parentNode; }
        while (!(nextAncestor = ancestor.nextSibling) && ancestor.parentNode);
      }
      if (nextAncestor) return (e > a && e < nextAncestor.sourceIndex);
    }

    while (element = element.parentNode)
      if (element == originalAncestor) return true;
    return false;
  },

  |>METHOD:scrollTo<|: function(element) {
    element = $(element);
    var pos = element.cumulativeOffset();
    |>GLOBAL:window<|.scrollTo(pos[0], pos[1]);
    return element;
  },

  |>METHOD:getStyle<|: function(element, style) {
    element = $(element);
    style = style == 'float' ? 'cssFloat' : style.camelize();
    var value = element.style[style];
    if (!value) {
      var css = |>GLOBAL:document<|.defaultView.getComputedStyle(element, null);
      value = css ? css[style] : null;
    }
    if (style == 'opacity') return value ? parseFloat(value) : 1.0;
    return value == 'auto' ? null : value;
  },

  |>METHOD:getOpacity<|: function(element) {
    return $(element).getStyle('opacity');
  },

  |>METHOD:setStyle<|: function(element, styles) {
    element = $(element);
    var elementStyle = element.style, |>UNUSED:match<|;
    if (|>CLASS:Object<|.isString(styles)) {
      element.style.cssText += ';' + styles;
      return styles.include('opacity') ?
        element.setOpacity(styles.match(|>REGEXP:/opacity:\s*(\d?\.?\d*)/<|)[1]) : element;
    }
    for (var property in styles)
      if (property == 'opacity') element.setOpacity(styles[property]);
      else
        elementStyle[(property == 'float' || property == 'cssFloat') ?
          (|>CLASS:Object<|.isUndefined(elementStyle.styleFloat) ? 'cssFloat' : 'styleFloat') :
            property] = styles[property];

    return element;
  },

  |>METHOD:setOpacity<|: function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1 || value === '') ? '' :
      (value < 0.00001) ? 0 : value;
    return element;
  },

  |>METHOD:getDimensions<|: function(element) {
    element = $(element);
    var display = $(element).getStyle('display');
    if (display != 'none' && display != null) // Safari bug
      return {width: element.offsetWidth, height: element.offsetHeight};

    // All *Width and *Height properties give 0 on elements with display none,
    // so enable the element temporarily
    var els = element.style;
    var originalVisibility = els.visibility;
    var originalPosition = els.position;
    var originalDisplay = els.display;
    els.visibility = 'hidden';
    els.position = 'absolute';
    els.display = 'block';
    var originalWidth = element.clientWidth;
    var originalHeight = element.clientHeight;
    els.display = originalDisplay;
    els.position = originalPosition;
    els.visibility = originalVisibility;
    return {width: originalWidth, height: originalHeight};
  },

  |>METHOD:makePositioned<|: function(element) {
    element = $(element);
    var pos = |>CLASS:Element<|.getStyle(element, 'position');
    if (pos == 'static' || !pos) {
      element._madePositioned = true;
      element.style.position = 'relative';
      // Opera returns the offset relative to the positioning context, when an
      // element is position relative but top and left have not been defined
      if (|>GLOBAL:window<|.opera) {
        element.style.top = 0;
        element.style.left = 0;
      }
    }
    return element;
  },

  |>METHOD:undoPositioned<|: function(element) {
    element = $(element);
    if (element._madePositioned) {
      element._madePositioned = undefined;
      element.style.position =
        element.style.top =
        element.style.left =
        element.style.bottom =
        element.style.right = '';
    }
    return element;
  },

  |>METHOD:makeClipping<|: function(element) {
    element = $(element);
    if (element._overflow) return element;
    element._overflow = |>CLASS:Element<|.getStyle(element, 'overflow') || 'auto';
    if (element._overflow !== 'hidden')
      element.style.overflow = 'hidden';
    return element;
  },

  |>METHOD:undoClipping<|: function(element) {
    element = $(element);
    if (!element._overflow) return element;
    element.style.overflow = element._overflow == 'auto' ? '' : element._overflow;
    element._overflow = null;
    return element;
  },

  |>METHOD:cumulativeOffset<|: function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      element = element.offsetParent;
    } while (element);
    return |>CLASS:Element<|._returnOffset(valueL, valueT);
  },

  |>METHOD:positionedOffset<|: function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      element = element.offsetParent;
      if (element) {
        if (element.tagName == 'BODY') break;
        var p = |>CLASS:Element<|.getStyle(element, 'position');
        if (p == 'relative' || p == 'absolute') break;
      }
    } while (element);
    return |>CLASS:Element<|._returnOffset(valueL, valueT);
  },

  |>METHOD:absolutize<|: function(element) {
    element = $(element);
    if (element.getStyle('position') == 'absolute') return;
    // Position.prepare(); // To be done manually by Scripty when it needs it.

    var offsets = element.positionedOffset();
    var top     = offsets[1];
    var left    = offsets[0];
    var width   = element.clientWidth;
    var height  = element.clientHeight;

    element._originalLeft   = left - parseFloat(element.style.left  || 0);
    element._originalTop    = top  - parseFloat(element.style.top || 0);
    element._originalWidth  = element.style.width;
    element._originalHeight = element.style.height;

    element.style.position = 'absolute';
    element.style.top    = top + 'px';
    element.style.left   = left + 'px';
    element.style.width  = width + 'px';
    element.style.height = height + 'px';
    return element;
  },

  |>METHOD:relativize<|: function(element) {
    element = $(element);
    if (element.getStyle('position') == 'relative') return;
    // Position.prepare(); // To be done manually by Scripty when it needs it.

    element.style.position = 'relative';
    var top  = parseFloat(element.style.top  || 0) - (element._originalTop || 0);
    var left = parseFloat(element.style.left || 0) - (element._originalLeft || 0);

    element.style.top    = top + 'px';
    element.style.left   = left + 'px';
    element.style.height = element._originalHeight;
    element.style.width  = element._originalWidth;
    return element;
  },

  |>METHOD:cumulativeScrollOffset<|: function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.scrollTop  || 0;
      valueL += element.scrollLeft || 0;
      element = element.parentNode;
    } while (element);
    return |>CLASS:Element<|._returnOffset(valueL, valueT);
  },

  |>METHOD:getOffsetParent<|: function(element) {
    if (element.offsetParent) return $(element.offsetParent);
    if (element == |>GLOBAL:document<|.body) return $(element);

    while ((element = element.parentNode) && element != |>GLOBAL:document<|.body)
      if (|>CLASS:Element<|.getStyle(element, 'position') != 'static')
        return $(element);

    return $(|>GLOBAL:document<|.body);
  },

  |>METHOD:viewportOffset<|: function(forElement) {
    var valueT = 0, valueL = 0;

    var element = forElement;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;

      // Safari fix
      if (element.offsetParent == |>GLOBAL:document<|.body &&
        |>CLASS:Element<|.getStyle(element, 'position') == 'absolute') break;

    } while (element = element.offsetParent);

    element = forElement;
    do {
      if (!|>CLASS:Prototype<|.Browser.Opera || element.tagName == 'BODY') {
        valueT -= element.scrollTop  || 0;
        valueL -= element.scrollLeft || 0;
      }
    } while (element = element.parentNode);

    return |>CLASS:Element<|._returnOffset(valueL, valueT);
  },

  |>METHOD:clonePosition<|: function(element, source) {
    var options = |>CLASS:Object<|.extend({
      setLeft:    true,
      setTop:     true,
      setWidth:   true,
      setHeight:  true,
      offsetTop:  0,
      offsetLeft: 0
    }, arguments[2] || { });

    // find page position of source
    source = $(source);
    var p = source.viewportOffset();

    // find coordinate system to use
    element = $(element);
    var delta = [0, 0];
    var parent = null;
    // delta [0,0] will do fine with position: fixed elements,
    // position:absolute needs offsetParent deltas
    if (|>CLASS:Element<|.getStyle(element, 'position') == 'absolute') {
      parent = element.getOffsetParent();
      delta = parent.viewportOffset();
    }

    // correct by body offsets (fixes Safari)
    if (parent == |>GLOBAL:document<|.body) {
      delta[0] -= |>GLOBAL:document<|.body.offsetLeft;
      delta[1] -= |>GLOBAL:document<|.body.offsetTop;
    }

    // set position
    if (options.setLeft)   element.style.left  = (p[0] - delta[0] + options.offsetLeft) + 'px';
    if (options.setTop)    element.style.top   = (p[1] - delta[1] + options.offsetTop) + 'px';
    if (options.setWidth)  element.style.width = source.offsetWidth + 'px';
    if (options.setHeight) element.style.height = source.offsetHeight + 'px';
    return element;
  }
};

|>CLASS:Element<|.Methods.identify.counter = 1;

|>CLASS:Object<|.extend(|>CLASS:Element<|.Methods, {
  getElementsBySelector: |>CLASS:Element<|.Methods.select,
  childElements: |>CLASS:Element<|.Methods.immediateDescendants
});

|>CLASS:Element<|._attributeTranslations = {
  write: {
    names: {
      className: 'class',
      htmlFor:   'for'
    },
    values: { }
  }
};


if (!|>GLOBAL:document<|.createRange || |>CLASS:Prototype<|.Browser.Opera) {
  |>CLASS:Element<|.Methods.insert = function(element, insertions) {
    element = $(element);

    if (|>CLASS:Object<|.isString(insertions) || |>CLASS:Object<|.isNumber(insertions) ||
        |>CLASS:Object<|.isElement(insertions) || (insertions && (insertions.toElement || insertions.toHTML)))
          insertions = { bottom: insertions };

    var t = |>CLASS:Element<|._insertionTranslations, content, position, pos, tagName;

    for (position in insertions) {
      content  = insertions[position];
      position = position.toLowerCase();
      pos      = t[position];

      if (content && content.toElement) content = content.toElement();
      if (|>CLASS:Object<|.isElement(content)) {
        pos.insert(element, content);
        continue;
      }

      content = |>CLASS:Object<|.toHTML(content);
      tagName = ((position == 'before' || position == 'after')
        ? element.parentNode : element).tagName.toUpperCase();

      if (t.tags[tagName]) {
        var fragments = |>CLASS:Element<|._getContentFromAnonymousElement(tagName, content.stripScripts());
        if (position == 'top' || position == 'after') fragments.reverse();
        fragments.each(pos.insert.curry(element));
      }
      else element.insertAdjacentHTML(pos.adjacency, content.stripScripts());

      content.evalScripts.bind(content).defer();
    }

    return element;
  };
}

if (|>CLASS:Prototype<|.Browser.Opera) {
  |>CLASS:Element<|.Methods.getStyle = |>CLASS:Element<|.Methods.getStyle.wrap(
    function(proceed, element, style) {
      switch (style) {
        case 'left': case 'top': case 'right': case 'bottom':
          if (proceed(element, 'position') === 'static') return null;
        case 'height': case 'width':
          // returns '0px' for hidden elements; we want it to return null
          if (!|>CLASS:Element<|.visible(element)) return null;

          // returns the border-box dimensions rather than the content-box
          // dimensions, so we subtract padding and borders from the value
          var dim = parseInt(proceed(element, style), 10);

          if (dim !== element['offset' + style.capitalize()])
            return dim + 'px';

          var properties;
          if (style === 'height') {
            properties = ['border-top-width', 'padding-top',
             'padding-bottom', 'border-bottom-width'];
          }
          else {
            properties = ['border-left-width', 'padding-left',
             'padding-right', 'border-right-width'];
          }
          return properties.inject(dim, function(memo, property) {
            var val = proceed(element, property);
            return val === null ? memo : memo - parseInt(val, 10);
          }) + 'px';
        default: return proceed(element, style);
      }
    }
  );

  |>CLASS:Element<|.Methods.readAttribute = |>CLASS:Element<|.Methods.readAttribute.wrap(
    function(proceed, element, attribute) {
      if (attribute === 'title') return element.title;
      return proceed(element, attribute);
    }
  );
}

else if (|>CLASS:Prototype<|.Browser.IE) {
  $w('positionedOffset getOffsetParent viewportOffset').each(function(method) {
    |>CLASS:Element<|.Methods[method] = |>CLASS:Element<|.Methods[method].wrap(
      function(proceed, element) {
        element = $(element);
        var position = element.getStyle('position');
        if (position != 'static') return proceed(element);
        element.setStyle({ position: 'relative' });
        var value = proceed(element);
        element.setStyle({ position: position });
        return value;
      }
    );
  });

  |>CLASS:Element<|.Methods.getStyle = function(element, style) {
    element = $(element);
    style = (style == 'float' || style == 'cssFloat') ? 'styleFloat' : style.camelize();
    var value = element.style[style];
    if (!value && element.currentStyle) value = element.currentStyle[style];

    if (style == 'opacity') {
      if (value = (element.getStyle('filter') || '').match(|>REGEXP:/alpha\(opacity=(.*)\)/<|))
        if (value[1]) return parseFloat(value[1]) / 100;
      return 1.0;
    }

    if (value == 'auto') {
      if ((style == 'width' || style == 'height') && (element.getStyle('display') != 'none'))
        return element['offset' + style.capitalize()] + 'px';
      return null;
    }
    return value;
  };

  |>CLASS:Element<|.Methods.setOpacity = function(element, value) {
    function |>METHOD:stripAlpha<|(filter){
      return filter.replace(|>REGEXP:/alpha\([^\)]*\)/gi<|,'');
    }
    element = $(element);
    var currentStyle = element.currentStyle;
    if ((currentStyle && !currentStyle.hasLayout) ||
      (!currentStyle && element.style.zoom == 'normal'))
        element.style.zoom = 1;

    var filter = element.getStyle('filter'), style = element.style;
    if (value == 1 || value === '') {
      (filter = stripAlpha(filter)) ?
        style.filter = filter : style.removeAttribute('filter');
      return element;
    } else if (value < 0.00001) value = 0;
    style.filter = stripAlpha(filter) +
      'alpha(opacity=' + (value * 100) + ')';
    return element;
  };

  |>CLASS:Element<|._attributeTranslations = {
    read: {
      names: {
        'class': 'className',
        'for':   'htmlFor'
      },
      values: {
        |>METHOD:_getAttr<|: function(element, attribute) {
          return element.getAttribute(attribute, 2);
        },
        |>METHOD:_getAttrNode<|: function(element, attribute) {
          var node = element.getAttributeNode(attribute);
          return node ? node.value : "";
        },
        |>METHOD:_getEv<|: function(element, attribute) {
          attribute = element.getAttribute(attribute);
          return attribute ? attribute.toString().slice(23, -2) : null;
        },
        |>METHOD:_flag<|: function(element, attribute) {
          return $(element).hasAttribute(attribute) ? attribute : null;
        },
        |>METHOD:style<|: function(element) {
          return element.style.cssText.toLowerCase();
        },
        |>METHOD:title<|: function(element) {
          return element.title;
        }
      }
    }
  };

  |>CLASS:Element<|._attributeTranslations.write = {
    names: |>CLASS:Object<|.clone(|>CLASS:Element<|._attributeTranslations.read.names),
    values: {
      |>METHOD:checked<|: function(element, value) {
        element.checked = !!value;
      },

      |>METHOD:style<|: function(element, value) {
        element.style.cssText = value ? value : '';
      }
    }
  };

  |>CLASS:Element<|._attributeTranslations.has = {};

  $w('colSpan rowSpan vAlign dateTime accessKey tabIndex ' +
      'encType maxLength readOnly longDesc').each(function(attr) {
    |>CLASS:Element<|._attributeTranslations.write.names[attr.toLowerCase()] = attr;
    |>CLASS:Element<|._attributeTranslations.has[attr.toLowerCase()] = attr;
  });

  (function(v) {
    |>CLASS:Object<|.extend(v, {
      href:        v._getAttr,
      src:         v._getAttr,
      type:        v._getAttr,
      action:      v._getAttrNode,
      disabled:    v._flag,
      checked:     v._flag,
      readonly:    v._flag,
      multiple:    v._flag,
      onload:      v._getEv,
      onunload:    v._getEv,
      onclick:     v._getEv,
      ondblclick:  v._getEv,
      onmousedown: v._getEv,
      onmouseup:   v._getEv,
      onmouseover: v._getEv,
      onmousemove: v._getEv,
      onmouseout:  v._getEv,
      onfocus:     v._getEv,
      onblur:      v._getEv,
      onkeypress:  v._getEv,
      onkeydown:   v._getEv,
      onkeyup:     v._getEv,
      onsubmit:    v._getEv,
      onreset:     v._getEv,
      onselect:    v._getEv,
      onchange:    v._getEv
    });
  })(|>CLASS:Element<|._attributeTranslations.read.values);
}

else if (|>CLASS:Prototype<|.Browser.Gecko && |>REGEXP:/rv:1\.8\.0/<|.test(|>GLOBAL:navigator<|.userAgent)) {
  |>CLASS:Element<|.Methods.setOpacity = function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1) ? 0.999999 :
      (value === '') ? '' : (value < 0.00001) ? 0 : value;
    return element;
  };
}

else if (|>CLASS:Prototype<|.Browser.WebKit) {
  |>CLASS:Element<|.Methods.setOpacity = function(element, value) {
    element = $(element);
    element.style.opacity = (value == 1 || value === '') ? '' :
      (value < 0.00001) ? 0 : value;

    if (value == 1)
      if(element.tagName == 'IMG' && element.width) {
        element.width++; element.width--;
      } else try {
        var n = |>GLOBAL:document<|.createTextNode(' ');
        element.appendChild(n);
        element.removeChild(n);
      } catch (|>UNUSED:e<|) { }

    return element;
  };

  // Safari returns margins on body which is incorrect if the child is absolutely
  // positioned.  For performance reasons, redefine Element#cumulativeOffset for
  // KHTML/WebKit only.
  |>CLASS:Element<|.Methods.cumulativeOffset = function(element) {
    var valueT = 0, valueL = 0;
    do {
      valueT += element.offsetTop  || 0;
      valueL += element.offsetLeft || 0;
      if (element.offsetParent == |>GLOBAL:document<|.body)
        if (|>CLASS:Element<|.getStyle(element, 'position') == 'absolute') break;

      element = element.offsetParent;
    } while (element);

    return |>CLASS:Element<|._returnOffset(valueL, valueT);
  };
}

if (|>CLASS:Prototype<|.Browser.IE || |>CLASS:Prototype<|.Browser.Opera) {
  // IE and Opera are missing .innerHTML support for TABLE-related and SELECT elements
  |>CLASS:Element<|.Methods.update = function(element, content) {
    element = $(element);

    if (content && content.toElement) content = content.toElement();
    if (|>CLASS:Object<|.isElement(content)) return element.update().insert(content);

    content = |>CLASS:Object<|.toHTML(content);
    var tagName = element.tagName.toUpperCase();

    if (tagName in |>CLASS:Element<|._insertionTranslations.tags) {
      $A(element.childNodes).each(function(node) { element.removeChild(node) });
      |>CLASS:Element<|._getContentFromAnonymousElement(tagName, content.stripScripts())
        .each(function(node) { element.appendChild(node) });
    }
    else element.innerHTML = content.stripScripts();

    content.evalScripts.bind(content).defer();
    return element;
  };
}

if (|>GLOBAL:document<|.createElement('div').outerHTML) {
  |>CLASS:Element<|.Methods.replace = function(element, content) {
    element = $(element);

    if (content && content.toElement) content = content.toElement();
    if (|>CLASS:Object<|.isElement(content)) {
      element.parentNode.replaceChild(content, element);
      return element;
    }

    content = |>CLASS:Object<|.toHTML(content);
    var parent = element.parentNode, tagName = parent.tagName.toUpperCase();

    if (|>CLASS:Element<|._insertionTranslations.tags[tagName]) {
      var nextSibling = element.next();
      var fragments = |>CLASS:Element<|._getContentFromAnonymousElement(tagName, content.stripScripts());
      parent.removeChild(element);
      if (nextSibling)
        fragments.each(function(node) { parent.insertBefore(node, nextSibling) });
      else
        fragments.each(function(node) { parent.appendChild(node) });
    }
    else element.outerHTML = content.stripScripts();

    content.evalScripts.bind(content).defer();
    return element;
  };
}

|>CLASS:Element<|._returnOffset = function(l, t) {
  var result = [l, t];
  result.left = l;
  result.top = t;
  return result;
};

|>CLASS:Element<|._getContentFromAnonymousElement = function(tagName, html) {
  var div = new |>CLASS:Element<|('div'), t = |>CLASS:Element<|._insertionTranslations.tags[tagName];
  div.innerHTML = t[0] + html + t[1];
  t[2].times(function() { div = div.firstChild });
  return $A(div.childNodes);
};

|>CLASS:Element<|._insertionTranslations = {
  before: {
    adjacency: 'beforeBegin',
    |>METHOD:insert<|: function(element, node) {
      element.parentNode.insertBefore(node, element);
    },
    |>METHOD:initializeRange<|: function(element, range) {
      range.setStartBefore(element);
    }
  },
  top: {
    adjacency: 'afterBegin',
    |>METHOD:insert<|: function(element, node) {
      element.insertBefore(node, element.firstChild);
    },
    |>METHOD:initializeRange<|: function(element, range) {
      range.selectNodeContents(element);
      range.collapse(true);
    }
  },
  bottom: {
    adjacency: 'beforeEnd',
    |>METHOD:insert<|: function(element, node) {
      element.appendChild(node);
    }
  },
  after: {
    adjacency: 'afterEnd',
    |>METHOD:insert<|: function(element, node) {
      element.parentNode.insertBefore(node, element.nextSibling);
    },
    |>METHOD:initializeRange<|: function(element, range) {
      range.setStartAfter(element);
    }
  },
  tags: {
    TABLE:  ['<table>',                '</table>',                   1],
    TBODY:  ['<table><tbody>',         '</tbody></table>',           2],
    TR:     ['<table><tbody><tr>',     '</tr></tbody></table>',      3],
    TD:     ['<table><tbody><tr><td>', '</td></tr></tbody></table>', 4],
    SELECT: ['<select>',               '</select>',                  1]
  }
};

(function() {
  this.bottom.initializeRange = this.top.initializeRange;
  |>CLASS:Object<|.extend(this.tags, {
    THEAD: this.tags.TBODY,
    TFOOT: this.tags.TBODY,
    TH:    this.tags.TD
  });
}).call(|>CLASS:Element<|._insertionTranslations);

|>CLASS:Element<|.Methods.Simulated = {
  |>METHOD:hasAttribute<|: function(element, attribute) {
    attribute = |>CLASS:Element<|._attributeTranslations.has[attribute] || attribute;
    var node = $(element).getAttributeNode(attribute);
    return node && node.specified;
  }
};

|>CLASS:Element<|.Methods.ByTag = { };

|>CLASS:Object<|.extend(|>CLASS:Element<|, |>CLASS:Element<|.Methods);

if (!|>CLASS:Prototype<|.BrowserFeatures.ElementExtensions &&
    |>GLOBAL:document<|.createElement('div').__proto__) {
  |>GLOBAL:window<|.HTMLElement = { };
  |>GLOBAL:window<|.HTMLElement.prototype = |>GLOBAL:document<|.createElement('div').__proto__;
  |>CLASS:Prototype<|.BrowserFeatures.ElementExtensions = true;
}

|>CLASS:Element<|.extend = (function() {
  if (|>CLASS:Prototype<|.BrowserFeatures.SpecificElementExtensions)
    return |>CLASS:Prototype<|.K;

  var Methods = { }, ByTag = |>CLASS:Element<|.Methods.ByTag;

  var extend = |>CLASS:Object<|.extend(function(element) {
    if (!element || element._extendedByPrototype ||
        element.nodeType != 1 || element == |>GLOBAL:window<|) return element;

    var methods = |>CLASS:Object<|.clone(Methods),
      tagName = element.tagName, property, value;

    // extend methods for specific tags
    if (ByTag[tagName]) |>CLASS:Object<|.extend(methods, ByTag[tagName]);

    for (property in methods) {
      value = methods[property];
      if (|>CLASS:Object<|.isFunction(value) && !(property in element))
        element[property] = value.methodize();
    }

    element._extendedByPrototype = |>CLASS:Prototype<|.emptyFunction;
    return element;

  }, {
    |>METHOD:refresh<|: function() {
      // extend methods for all tags (Safari doesn't need this)
      if (!|>CLASS:Prototype<|.BrowserFeatures.ElementExtensions) {
        |>CLASS:Object<|.extend(Methods, |>CLASS:Element<|.Methods);
        |>CLASS:Object<|.extend(Methods, |>CLASS:Element<|.Methods.Simulated);
      }
    }
  });

  extend.refresh();
  return extend;
})();

|>CLASS:Element<|.hasAttribute = function(element, attribute) {
  if (element.hasAttribute) return element.hasAttribute(attribute);
  return |>CLASS:Element<|.Methods.Simulated.hasAttribute(element, attribute);
};

|>CLASS:Element<|.addMethods = function(methods) {
  var F = |>CLASS:Prototype<|.BrowserFeatures, T = |>CLASS:Element<|.Methods.ByTag;

  if (!methods) {
    |>CLASS:Object<|.extend(|>CLASS:Form<|, |>CLASS:Form<|.Methods);
    |>CLASS:Object<|.extend(|>CLASS:Form<|.Element, |>CLASS:Form<|.Element.Methods);
    |>CLASS:Object<|.extend(|>CLASS:Element<|.Methods.ByTag, {
      "FORM":     |>CLASS:Object<|.clone(|>CLASS:Form<|.Methods),
      "INPUT":    |>CLASS:Object<|.clone(|>CLASS:Form<|.Element.Methods),
      "SELECT":   |>CLASS:Object<|.clone(|>CLASS:Form<|.Element.Methods),
      "TEXTAREA": |>CLASS:Object<|.clone(|>CLASS:Form<|.Element.Methods)
    });
  }

  if (arguments.length == 2) {
    var tagName = methods;
    methods = arguments[1];
  }

  if (!tagName) |>CLASS:Object<|.extend(|>CLASS:Element<|.Methods, methods || { });
  else {
    if (|>CLASS:Object<|.isArray(tagName)) tagName.each(|>GLOBAL:extend<|);
    else |>GLOBAL:extend<|(tagName);
  }

  function |>METHOD:extend<|(tagName) {
    tagName = tagName.toUpperCase();
    if (!|>CLASS:Element<|.Methods.ByTag[tagName])
      |>CLASS:Element<|.Methods.ByTag[tagName] = { };
    |>CLASS:Object<|.extend(|>CLASS:Element<|.Methods.ByTag[tagName], methods);
  }

  function |>METHOD:copy<|(methods, destination, onlyIfAbsent) {
    onlyIfAbsent = onlyIfAbsent || false;
    for (var property in methods) {
      var value = methods[property];
      if (!|>CLASS:Object<|.isFunction(value)) continue;
      if (!onlyIfAbsent || !(property in destination))
        destination[property] = value.methodize();
    }
  }

  function |>METHOD:findDOMClass<|(tagName) {
    var klass;
    var trans = {
      "OPTGROUP": "OptGroup", "TEXTAREA": "TextArea", "P": "Paragraph",
      "FIELDSET": "FieldSet", "UL": "UList", "OL": "OList", "DL": "DList",
      "DIR": "Directory", "H1": "Heading", "H2": "Heading", "H3": "Heading",
      "H4": "Heading", "H5": "Heading", "H6": "Heading", "Q": "Quote",
      "INS": "Mod", "DEL": "Mod", "A": "Anchor", "IMG": "Image", "CAPTION":
      "TableCaption", "COL": "TableCol", "COLGROUP": "TableCol", "THEAD":
      "TableSection", "TFOOT": "TableSection", "TBODY": "TableSection", "TR":
      "TableRow", "TH": "TableCell", "TD": "TableCell", "FRAMESET":
      "FrameSet", "IFRAME": "IFrame"
    };
    if (trans[tagName]) klass = 'HTML' + trans[tagName] + 'Element';
    if (|>GLOBAL:window<|[klass]) return |>GLOBAL:window<|[klass];
    klass = 'HTML' + tagName + 'Element';
    if (|>GLOBAL:window<|[klass]) return |>GLOBAL:window<|[klass];
    klass = 'HTML' + tagName.capitalize() + 'Element';
    if (|>GLOBAL:window<|[klass]) return |>GLOBAL:window<|[klass];

    |>GLOBAL:window<|[klass] = { };
    |>GLOBAL:window<|[klass].prototype = |>GLOBAL:document<|.createElement(tagName).__proto__;
    return |>GLOBAL:window<|[klass];
  }

  if (F.ElementExtensions) {
    copy(|>CLASS:Element<|.Methods, |>CLASS:HTMLElement<|.prototype);
    copy(|>CLASS:Element<|.Methods.Simulated, |>CLASS:HTMLElement<|.prototype, true);
  }

  if (F.SpecificElementExtensions) {
    for (var tag in |>CLASS:Element<|.Methods.ByTag) {
      var klass = findDOMClass(tag);
      if (|>CLASS:Object<|.isUndefined(klass)) continue;
      copy(T[tag], klass.prototype);
    }
  }

  |>CLASS:Object<|.extend(|>CLASS:Element<|, |>CLASS:Element<|.Methods);
  delete |>CLASS:Element<|.ByTag;

  if (|>CLASS:Element<|.extend.refresh) |>CLASS:Element<|.extend.refresh();
  |>CLASS:Element<|.cache = { };
};

|>GLOBAL:document<|.viewport = {
  |>METHOD:getDimensions<|: function() {
    var dimensions = { };
    var B = |>CLASS:Prototype<|.Browser;
    $w('width height').each(function(d) {
      var D = d.capitalize();
      dimensions[d] = (B.WebKit && !|>GLOBAL:document<|.evaluate) ? |>GLOBAL:self<|['inner' + D] :
        (B.Opera) ? |>GLOBAL:document<|.body['client' + D] : |>GLOBAL:document<|.documentElement['client' + D];
    });
    return dimensions;
  },

  |>METHOD:getWidth<|: function() {
    return this.getDimensions().width;
  },

  |>METHOD:getHeight<|: function() {
    return this.getDimensions().height;
  },

  |>METHOD:getScrollOffsets<|: function() {
    return |>CLASS:Element<|._returnOffset(
      |>GLOBAL:window<|.pageXOffset || |>GLOBAL:document<|.documentElement.scrollLeft || |>GLOBAL:document<|.body.scrollLeft,
      |>GLOBAL:window<|.pageYOffset || |>GLOBAL:document<|.documentElement.scrollTop || |>GLOBAL:document<|.body.scrollTop);
  }
};
/* Portions of the Selector class are derived from Jack Slocums DomQuery,
 * part of YUI-Ext version 0.40, distributed under the terms of an MIT-style
 * license.  Please see http://www.yui-ext.com/ for more information. */

var |>CLASS:Selector<| = |>CLASS:Class<|.create({
  |>METHOD:initialize<|: function(expression) {
    this.expression = expression.strip();
    this.compileMatcher();
  },

  |>METHOD:shouldUseXPath<|: function() {
    if (!|>CLASS:Prototype<|.BrowserFeatures.XPath) return false;

    var e = this.expression;

    // Safari 3 chokes on :*-of-type and :empty
    if (|>CLASS:Prototype<|.Browser.WebKit &&
     (e.include("-of-type") || e.include(":empty")))
      return false;

    // XPath can't do namespaced attributes, nor can it read
    // the "checked" property from DOM nodes
    if ((|>REGEXP:/(\[[\w-]*?:|:checked)/<|).test(this.expression))
      return false;

    return true;
  },

  |>METHOD:compileMatcher<|: function() {
    if (this.shouldUseXPath())
      return this.compileXPathMatcher();

    var e = this.expression, ps = |>CLASS:Selector<|.patterns, |>UNUSED:h<| = |>CLASS:Selector<|.handlers,
        c = |>CLASS:Selector<|.criteria, le, p, m;

    if (|>CLASS:Selector<|._cache[e]) {
      this.matcher = |>CLASS:Selector<|._cache[e];
      return;
    }

    this.matcher = ["this.matcher = function(root) {",
                    "var r = root, h = Selector.handlers, c = false, n;"];

    while (e && le != e && (|>REGEXP:/\S/<|).test(e)) {
      le = e;
      for (var i in ps) {
        p = ps[i];
        if (m = e.match(p)) {
          this.matcher.push(|>CLASS:Object<|.isFunction(c[i]) ? c[i](m) :
    	      new |>CLASS:Template<|(c[i]).evaluate(m));
          e = e.replace(m[0], '');
          break;
        }
      }
    }

    this.matcher.push("return h.unique(n);\n}");
    eval(this.matcher.join('\n'));
    |>CLASS:Selector<|._cache[this.expression] = this.matcher;
  },

  |>METHOD:compileXPathMatcher<|: function() {
    var e = this.expression, ps = |>CLASS:Selector<|.patterns,
        x = |>CLASS:Selector<|.xpath, le, m;

    if (|>CLASS:Selector<|._cache[e]) {
      this.xpath = |>CLASS:Selector<|._cache[e]; return;
    }

    this.matcher = ['.//*'];
    while (e && le != e && (|>REGEXP:/\S/<|).test(e)) {
      le = e;
      for (var i in ps) {
        if (m = e.match(ps[i])) {
          this.matcher.push(|>CLASS:Object<|.isFunction(x[i]) ? x[i](m) :
            new |>CLASS:Template<|(x[i]).evaluate(m));
          e = e.replace(m[0], '');
          break;
        }
      }
    }

    this.xpath = this.matcher.join('');
    |>CLASS:Selector<|._cache[this.expression] = this.xpath;
  },

  |>METHOD:findElements<|: function(root) {
    root = root || |>GLOBAL:document<|;
    if (this.xpath) return |>GLOBAL:document<|._getElementsByXPath(this.xpath, root);
    return this.matcher(root);
  },

  |>METHOD:match<|: function(element) {
    this.tokens = [];

    var e = this.expression, ps = |>CLASS:Selector<|.patterns, as = |>CLASS:Selector<|.assertions;
    var le, p, m;

    while (e && le !== e && (|>REGEXP:/\S/<|).test(e)) {
      le = e;
      for (var i in ps) {
        p = ps[i];
        if (m = e.match(p)) {
          // use the Selector.assertions methods unless the selector
          // is too complex.
          if (as[i]) {
            this.tokens.push([i, |>CLASS:Object<|.clone(m)]);
            e = e.replace(m[0], '');
          } else {
            // reluctantly do a document-wide search
            // and look for a match in the array
            return this.findElements(|>GLOBAL:document<|).include(element);
          }
        }
      }
    }

    var match = true, name, matches;
    for (var i = 0, token; token = this.tokens[i]; i++) {
      name = token[0], matches = token[1];
      if (!|>CLASS:Selector<|.assertions[name](element, matches)) {
        match = false; break;
      }
    }

    return match;
  },

  |>METHOD:toString<|: function() {
    return this.expression;
  },

  |>METHOD:inspect<|: function() {
    return "#<Selector:" + this.expression.inspect() + ">";
  }
});

|>CLASS:Object<|.extend(|>CLASS:Selector<|, {
  _cache: { },

  xpath: {
    descendant:   "//*",
    child:        "/*",
    adjacent:     "/following-sibling::*[1]",
    laterSibling: '/following-sibling::*',
    |>METHOD:tagName<|:      function(m) {
      if (m[1] == '*') return '';
      return "[local-name()='" + m[1].toLowerCase() +
             "' or local-name()='" + m[1].toUpperCase() + "']";
    },
    className:    "[contains(concat(' ', @class, ' '), ' #{1} ')]",
    id:           "[@id='#{1}']",
    |>METHOD:attrPresence<|: function(m) {
      m[1] = m[1].toLowerCase();
      return new |>CLASS:Template<|("[@#{1}]").evaluate(m);
    },
    |>METHOD:attr<|: function(m) {
      m[1] = m[1].toLowerCase();
      m[3] = m[5] || m[6];
      return new |>CLASS:Template<|(|>CLASS:Selector<|.xpath.operators[m[2]]).evaluate(m);
    },
    |>METHOD:pseudo<|: function(m) {
      var h = |>CLASS:Selector<|.xpath.pseudos[m[1]];
      if (!h) return '';
      if (|>CLASS:Object<|.isFunction(h)) return h(m);
      return new |>CLASS:Template<|(|>CLASS:Selector<|.xpath.pseudos[m[1]]).evaluate(m);
    },
    operators: {
      '=':  "[@#{1}='#{3}']",
      '!=': "[@#{1}!='#{3}']",
      '^=': "[starts-with(@#{1}, '#{3}')]",
      '$=': "[substring(@#{1}, (string-length(@#{1}) - string-length('#{3}') + 1))='#{3}']",
      '*=': "[contains(@#{1}, '#{3}')]",
      '~=': "[contains(concat(' ', @#{1}, ' '), ' #{3} ')]",
      '|=': "[contains(concat('-', @#{1}, '-'), '-#{3}-')]"
    },
    pseudos: {
      'first-child': '[not(preceding-sibling::*)]',
      'last-child':  '[not(following-sibling::*)]',
      'only-child':  '[not(preceding-sibling::* or following-sibling::*)]',
      'empty':       "[count(*) = 0 and (count(text()) = 0 or translate(text(), ' \t\r\n', '') = '')]",
      'checked':     "[@checked]",
      'disabled':    "[@disabled]",
      'enabled':     "[not(@disabled)]",
      '|>METHOD:not<|': function(m) {
        var e = m[6], p = |>CLASS:Selector<|.patterns,
            x = |>CLASS:Selector<|.xpath, le, v;

        var exclusion = [];
        while (e && le != e && (|>REGEXP:/\S/<|).test(e)) {
          le = e;
          for (var i in p) {
            if (m = e.match(p[i])) {
              v = |>CLASS:Object<|.isFunction(x[i]) ? x[i](m) : new |>CLASS:Template<|(x[i]).evaluate(m);
              exclusion.push("(" + v.substring(1, v.length - 1) + ")");
              e = e.replace(m[0], '');
              break;
            }
          }
        }
        return "[not(" + exclusion.join(" and ") + ")]";
      },
      '|>METHOD:nth-child<|':      function(m) {
        return |>CLASS:Selector<|.xpath.pseudos.nth("(count(./preceding-sibling::*) + 1) ", m);
      },
      '|>METHOD:nth-last-child<|': function(m) {
        return |>CLASS:Selector<|.xpath.pseudos.nth("(count(./following-sibling::*) + 1) ", m);
      },
      '|>METHOD:nth-of-type<|':    function(m) {
        return |>CLASS:Selector<|.xpath.pseudos.nth("position() ", m);
      },
      '|>METHOD:nth-last-of-type<|': function(m) {
        return |>CLASS:Selector<|.xpath.pseudos.nth("(last() + 1 - position()) ", m);
      },
      '|>METHOD:first-of-type<|':  function(m) {
        m[6] = "1"; return |>CLASS:Selector<|.xpath.pseudos['nth-of-type'](m);
      },
      '|>METHOD:last-of-type<|':   function(m) {
        m[6] = "1"; return |>CLASS:Selector<|.xpath.pseudos['nth-last-of-type'](m);
      },
      '|>METHOD:only-of-type<|':   function(m) {
        var p = |>CLASS:Selector<|.xpath.pseudos; return p['first-of-type'](m) + p['last-of-type'](m);
      },
      |>METHOD:nth<|: function(fragment, m) {
        var mm, formula = m[6], predicate;
        if (formula == 'even') formula = '2n+0';
        if (formula == 'odd')  formula = '2n+1';
        if (mm = formula.match(|>REGEXP:/^(\d+)$/<|)) // digit only
          return '[' + fragment + "= " + mm[1] + ']';
        if (mm = formula.match(|>REGEXP:/^(-?\d*)?n(([+-])(\d+))?/<|)) { // an+b
          if (mm[1] == "-") mm[1] = -1;
          var a = mm[1] ? Number(mm[1]) : 1;
          var b = mm[2] ? Number(mm[2]) : 0;
          predicate = "[((#{fragment} - #{b}) mod #{a} = 0) and " +
          "((#{fragment} - #{b}) div #{a} >= 0)]";
          return new |>CLASS:Template<|(predicate).evaluate({
            fragment: fragment, a: a, b: b });
        }
      }
    }
  },

  criteria: {
    tagName:      'n = h.tagName(n, r, "#{1}", c);   c = false;',
    className:    'n = h.className(n, r, "#{1}", c); c = false;',
    id:           'n = h.id(n, r, "#{1}", c);        c = false;',
    attrPresence: 'n = h.attrPresence(n, r, "#{1}"); c = false;',
    |>METHOD:attr<|: function(m) {
      m[3] = (m[5] || m[6]);
      return new |>CLASS:Template<|('n = h.attr(n, r, "#{1}", "#{3}", "#{2}"); c = false;').evaluate(m);
    },
    |>METHOD:pseudo<|: function(m) {
      if (m[6]) m[6] = m[6].replace(|>REGEXP:/"/g<|, '\\"');
      return new |>CLASS:Template<|('n = h.pseudo(n, "#{1}", "#{6}", r, c); c = false;').evaluate(m);
    },
    descendant:   'c = "descendant";',
    child:        'c = "child";',
    adjacent:     'c = "adjacent";',
    laterSibling: 'c = "laterSibling";'
  },

  patterns: {
    // combinators must be listed first
    // (and descendant needs to be last combinator)
    laterSibling: |>REGEXP:/^\s*~\s*/<|,
    child:        |>REGEXP:/^\s*>\s*/<|,
    adjacent:     |>REGEXP:/^\s*\+\s*/<|,
    descendant:   |>REGEXP:/^\s/<|,

    // selectors follow
    tagName:      |>REGEXP:/^\s*(\*|[\w\-]+)(\b|$)?/<|,
    id:           |>REGEXP:/^#([\w\-\*]+)(\b|$)/<|,
    className:    |>REGEXP:/^\.([\w\-\*]+)(\b|$)/<|,
    pseudo:       |>REGEXP:/^:((first|last|nth|nth-last|only)(-child|-of-type)|empty|checked|(en|dis)abled|not)(\((.*?)\))?(\b|$|(?=\s)|(?=:))/<|,
    attrPresence: |>REGEXP:/^\[([\w]+)\]/<|,
    attr:         |>REGEXP:/\[((?:[\w-]*:)?[\w-]+)\s*(?:([!^$*~|]?=)\s*((['"])([^\4]*?)\4|([^'"][^\]]*?)))?\]/<|
  },

  // for Selector.match and Element#match
  assertions: {
    |>METHOD:tagName<|: function(element, matches) {
      return matches[1].toUpperCase() == element.tagName.toUpperCase();
    },

    |>METHOD:className<|: function(element, matches) {
      return |>CLASS:Element<|.hasClassName(element, matches[1]);
    },

    |>METHOD:id<|: function(element, matches) {
      return element.id === matches[1];
    },

    |>METHOD:attrPresence<|: function(element, matches) {
      return |>CLASS:Element<|.hasAttribute(element, matches[1]);
    },

    |>METHOD:attr<|: function(element, matches) {
      var nodeValue = |>CLASS:Element<|.readAttribute(element, matches[1]);
      return |>CLASS:Selector<|.operators[matches[2]](nodeValue, matches[3]);
    }
  },

  handlers: {
    // UTILITY FUNCTIONS
    // joins two collections
    |>METHOD:concat<|: function(a, b) {
      for (var i = 0, node; node = b[i]; i++)
        a.push(node);
      return a;
    },

    // marks an array of nodes for counting
    |>METHOD:mark<|: function(nodes) {
      for (var i = 0, node; node = nodes[i]; i++)
        node._counted = true;
      return nodes;
    },

    |>METHOD:unmark<|: function(nodes) {
      for (var i = 0, node; node = nodes[i]; i++)
        node._counted = undefined;
      return nodes;
    },

    // mark each child node with its position (for nth calls)
    // "ofType" flag indicates whether we're indexing for nth-of-type
    // rather than nth-child
    |>METHOD:index<|: function(parentNode, reverse, ofType) {
      parentNode._counted = true;
      if (reverse) {
        for (var nodes = parentNode.childNodes, i = nodes.length - 1, j = 1; i >= 0; i--) {
          var node = nodes[i];
          if (node.nodeType == 1 && (!ofType || node._counted)) node.nodeIndex = j++;
        }
      } else {
        for (var i = 0, j = 1, nodes = parentNode.childNodes; node = nodes[i]; i++)
          if (node.nodeType == 1 && (!ofType || node._counted)) node.nodeIndex = j++;
      }
    },

    // filters out duplicates and extends all nodes
    |>METHOD:unique<|: function(nodes) {
      if (nodes.length == 0) return nodes;
      var results = [], n;
      for (var i = 0, l = nodes.length; i < l; i++)
        if (!(n = nodes[i])._counted) {
          n._counted = true;
          results.push(|>CLASS:Element<|.extend(n));
        }
      return |>CLASS:Selector<|.handlers.unmark(results);
    },

    // COMBINATOR FUNCTIONS
    |>METHOD:descendant<|: function(nodes) {
      var h = |>CLASS:Selector<|.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        h.concat(results, node.getElementsByTagName('*'));
      return results;
    },

    |>METHOD:child<|: function(nodes) {
      var |>UNUSED:h<| = |>CLASS:Selector<|.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        for (var j = 0, child; child = node.childNodes[j]; j++)
          if (child.nodeType == 1 && child.tagName != '!') results.push(child);
      }
      return results;
    },

    |>METHOD:adjacent<|: function(nodes) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        var next = this.nextElementSibling(node);
        if (next) results.push(next);
      }
      return results;
    },

    |>METHOD:laterSibling<|: function(nodes) {
      var h = |>CLASS:Selector<|.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        h.concat(results, |>CLASS:Element<|.nextSiblings(node));
      return results;
    },

    |>METHOD:nextElementSibling<|: function(node) {
      while (node = node.nextSibling)
	      if (node.nodeType == 1) return node;
      return null;
    },

    |>METHOD:previousElementSibling<|: function(node) {
      while (node = node.previousSibling)
        if (node.nodeType == 1) return node;
      return null;
    },

    // TOKEN FUNCTIONS
    |>METHOD:tagName<|: function(nodes, root, tagName, combinator) {
      tagName = tagName.toUpperCase();
      var results = [], h = |>CLASS:Selector<|.handlers;
      if (nodes) {
        if (combinator) {
          // fastlane for ordinary descendant combinators
          if (combinator == "descendant") {
            for (var i = 0, node; node = nodes[i]; i++)
              h.concat(results, node.getElementsByTagName(tagName));
            return results;
          } else nodes = this[combinator](nodes);
          if (tagName == "*") return nodes;
        }
        for (var i = 0, node; node = nodes[i]; i++)
          if (node.tagName.toUpperCase() == tagName) results.push(node);
        return results;
      } else return root.getElementsByTagName(tagName);
    },

    |>METHOD:id<|: function(nodes, root, id, combinator) {
      var targetNode = $(id), h = |>CLASS:Selector<|.handlers;
      if (!targetNode) return [];
      if (!nodes && root == |>GLOBAL:document<|) return [targetNode];
      if (nodes) {
        if (combinator) {
          if (combinator == 'child') {
            for (var i = 0, node; node = nodes[i]; i++)
              if (targetNode.parentNode == node) return [targetNode];
          } else if (combinator == 'descendant') {
            for (var i = 0, node; node = nodes[i]; i++)
              if (|>CLASS:Element<|.descendantOf(targetNode, node)) return [targetNode];
          } else if (combinator == 'adjacent') {
            for (var i = 0, node; node = nodes[i]; i++)
              if (|>CLASS:Selector<|.handlers.previousElementSibling(targetNode) == node)
                return [targetNode];
          } else nodes = h[combinator](nodes);
        }
        for (var i = 0, node; node = nodes[i]; i++)
          if (node == targetNode) return [targetNode];
        return [];
      }
      return (targetNode && |>CLASS:Element<|.descendantOf(targetNode, root)) ? [targetNode] : [];
    },

    |>METHOD:className<|: function(nodes, root, className, combinator) {
      if (nodes && combinator) nodes = this[combinator](nodes);
      return |>CLASS:Selector<|.handlers.byClassName(nodes, root, className);
    },

    |>METHOD:byClassName<|: function(nodes, root, className) {
      if (!nodes) nodes = |>CLASS:Selector<|.handlers.descendant([root]);
      var needle = ' ' + className + ' ';
      for (var i = 0, results = [], node, nodeClassName; node = nodes[i]; i++) {
        nodeClassName = node.className;
        if (nodeClassName.length == 0) continue;
        if (nodeClassName == className || (' ' + nodeClassName + ' ').include(needle))
          results.push(node);
      }
      return results;
    },

    |>METHOD:attrPresence<|: function(nodes, root, attr) {
      if (!nodes) nodes = root.getElementsByTagName("*");
      var results = [];
      for (var i = 0, node; node = nodes[i]; i++)
        if (|>CLASS:Element<|.hasAttribute(node, attr)) results.push(node);
      return results;
    },

    |>METHOD:attr<|: function(nodes, root, attr, value, operator) {
      if (!nodes) nodes = root.getElementsByTagName("*");
      var handler = |>CLASS:Selector<|.operators[operator], results = [];
      for (var i = 0, node; node = nodes[i]; i++) {
        var nodeValue = |>CLASS:Element<|.readAttribute(node, attr);
        if (nodeValue === null) continue;
        if (handler(nodeValue, value)) results.push(node);
      }
      return results;
    },

    |>METHOD:pseudo<|: function(nodes, name, value, root, combinator) {
      if (nodes && combinator) nodes = this[combinator](nodes);
      if (!nodes) nodes = root.getElementsByTagName("*");
      return |>CLASS:Selector<|.pseudos[name](nodes, value, root);
    }
  },

  pseudos: {
    '|>METHOD:first-child<|': function(nodes, |>UNUSED:value<|, |>UNUSED:root<|) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        if (|>CLASS:Selector<|.handlers.previousElementSibling(node)) continue;
          results.push(node);
      }
      return results;
    },
    '|>METHOD:last-child<|': function(nodes, |>UNUSED:value<|, |>UNUSED:root<|) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        if (|>CLASS:Selector<|.handlers.nextElementSibling(node)) continue;
          results.push(node);
      }
      return results;
    },
    '|>METHOD:only-child<|': function(nodes, |>UNUSED:value<|, |>UNUSED:root<|) {
      var h = |>CLASS:Selector<|.handlers;
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (!h.previousElementSibling(node) && !h.nextElementSibling(node))
          results.push(node);
      return results;
    },
    '|>METHOD:nth-child<|':        function(nodes, formula, root) {
      return |>CLASS:Selector<|.pseudos.nth(nodes, formula, root);
    },
    '|>METHOD:nth-last-child<|':   function(nodes, formula, root) {
      return |>CLASS:Selector<|.pseudos.nth(nodes, formula, root, true);
    },
    '|>METHOD:nth-of-type<|':      function(nodes, formula, root) {
      return |>CLASS:Selector<|.pseudos.nth(nodes, formula, root, false, true);
    },
    '|>METHOD:nth-last-of-type<|': function(nodes, formula, root) {
      return |>CLASS:Selector<|.pseudos.nth(nodes, formula, root, true, true);
    },
    '|>METHOD:first-of-type<|':    function(nodes, |>UNUSED:formula<|, root) {
      return |>CLASS:Selector<|.pseudos.nth(nodes, "1", root, false, true);
    },
    '|>METHOD:last-of-type<|':     function(nodes, |>UNUSED:formula<|, root) {
      return |>CLASS:Selector<|.pseudos.nth(nodes, "1", root, true, true);
    },
    '|>METHOD:only-of-type<|':     function(nodes, formula, root) {
      var p = |>CLASS:Selector<|.pseudos;
      return p['last-of-type'](p['first-of-type'](nodes, formula, root), formula, root);
    },

    // handles the an+b logic
    |>METHOD:getIndices<|: function(a, b, total) {
      if (a == 0) return b > 0 ? [b] : [];
      return $R(1, total).inject([], function(memo, i) {
        if (0 == (i - b) % a && (i - b) / a >= 0) memo.push(i);
        return memo;
      });
    },

    // handles nth(-last)-child, nth(-last)-of-type, and (first|last)-of-type
    |>METHOD:nth<|: function(nodes, formula, |>UNUSED:root<|, reverse, ofType) {
      if (nodes.length == 0) return [];
      if (formula == 'even') formula = '2n+0';
      if (formula == 'odd')  formula = '2n+1';
      var h = |>CLASS:Selector<|.handlers, results = [], indexed = [], m;
      h.mark(nodes);
      for (var i = 0, node; node = nodes[i]; i++) {
        if (!node.parentNode._counted) {
          h.index(node.parentNode, reverse, ofType);
          indexed.push(node.parentNode);
        }
      }
      if (formula.match(|>REGEXP:/^\d+$/<|)) { // just a number
        formula = Number(formula);
        for (var i = 0, node; node = nodes[i]; i++)
          if (node.nodeIndex == formula) results.push(node);
      } else if (m = formula.match(|>REGEXP:/^(-?\d*)?n(([+-])(\d+))?/<|)) { // an+b
        if (m[1] == "-") m[1] = -1;
        var a = m[1] ? Number(m[1]) : 1;
        var b = m[2] ? Number(m[2]) : 0;
        var indices = |>CLASS:Selector<|.pseudos.getIndices(a, b, nodes.length);
        for (var i = 0, node, l = indices.length; node = nodes[i]; i++) {
          for (var j = 0; j < l; j++)
            if (node.nodeIndex == indices[j]) results.push(node);
        }
      }
      h.unmark(nodes);
      h.unmark(indexed);
      return results;
    },

    '|>METHOD:empty<|': function(nodes, |>UNUSED:value<|, |>UNUSED:root<|) {
      for (var i = 0, results = [], node; node = nodes[i]; i++) {
        // IE treats comments as element nodes
        if (node.tagName == '!' || (node.firstChild && !node.innerHTML.match(|>REGEXP:/^\s*$/<|))) continue;
        results.push(node);
      }
      return results;
    },

    '|>METHOD:not<|': function(nodes, selector, root) {
      var h = |>CLASS:Selector<|.handlers, |>UNUSED:selectorType<|, |>UNUSED:m<|;
      var exclusions = new |>CLASS:Selector<|(selector).findElements(root);
      h.mark(exclusions);
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (!node._counted) results.push(node);
      h.unmark(exclusions);
      return results;
    },

    '|>METHOD:enabled<|': function(nodes, |>UNUSED:value<|, |>UNUSED:root<|) {
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (!node.disabled) results.push(node);
      return results;
    },

    '|>METHOD:disabled<|': function(nodes, |>UNUSED:value<|, |>UNUSED:root<|) {
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (node.disabled) results.push(node);
      return results;
    },

    '|>METHOD:checked<|': function(nodes, |>UNUSED:value<|, |>UNUSED:root<|) {
      for (var i = 0, results = [], node; node = nodes[i]; i++)
        if (node.checked) results.push(node);
      return results;
    }
  },

  operators: {
    '|>METHOD:=<|':  function(nv, v) { return nv == v; },
    '|>METHOD:!=<|': function(nv, v) { return nv != v; },
    '|>METHOD:^=<|': function(nv, v) { return nv.startsWith(v); },
    '|>METHOD:$=<|': function(nv, v) { return nv.endsWith(v); },
    '|>METHOD:*=<|': function(nv, v) { return nv.include(v); },
    '|>METHOD:~=<|': function(nv, v) { return (' ' + nv + ' ').include(' ' + v + ' '); },
    '|>METHOD:|=<|': function(nv, v) { return ('-' + nv.toUpperCase() + '-').include('-' + v.toUpperCase() + '-'); }
  },

  |>METHOD:matchElements<|: function(elements, expression) {
    var matches = new |>CLASS:Selector<|(expression).findElements(), h = |>CLASS:Selector<|.handlers;
    h.mark(matches);
    for (var i = 0, results = [], element; element = elements[i]; i++)
      if (element._counted) results.push(element);
    h.unmark(matches);
    return results;
  },

  |>METHOD:findElement<|: function(elements, expression, index) {
    if (|>CLASS:Object<|.isNumber(expression)) {
      index = expression; expression = false;
    }
    return |>CLASS:Selector<|.matchElements(elements, expression || '*')[index || 0];
  },

  |>METHOD:findChildElements<|: function(element, expressions) {
    var exprs = expressions.join(',');
    expressions = [];
    exprs.scan(|>REGEXP:/(([\w#:.~>+()\s-]+|\*|\[.*?\])+)\s*(,|$)/<|, function(m) {
      expressions.push(m[1].strip());
    });
    var results = [], h = |>CLASS:Selector<|.handlers;
    for (var i = 0, l = expressions.length, selector; i < l; i++) {
      selector = new |>CLASS:Selector<|(expressions[i].strip());
      h.concat(results, selector.findElements(element));
    }
    return (l > 1) ? h.unique(results) : results;
  }
});

if (|>CLASS:Prototype<|.Browser.IE) {
  // IE returns comment nodes on getElementsByTagName("*").
  // Filter them out.
  |>CLASS:Selector<|.handlers.concat = function(a, b) {
    for (var i = 0, node; node = b[i]; i++)
      if (node.tagName !== "!") a.push(node);
    return a;
  };
}

function |>METHOD:$$<|() {
  return |>CLASS:Selector<|.findChildElements(|>GLOBAL:document<|, $A(arguments));
}
var |>CLASS:Form<| = {
  |>METHOD:reset<|: function(form) {
    $(form).reset();
    return form;
  },

  |>METHOD:serializeElements<|: function(elements, options) {
    if (typeof options != 'object') options = { hash: !!options };
    else if (|>CLASS:Object<|.isUndefined(options.hash)) options.hash = true;
    var key, value, submitted = false, submit = options.submit;

    var data = elements.inject({ }, function(result, element) {
      if (!element.disabled && element.name) {
        key = element.name; value = $(element).getValue();
        if (value != null && (element.type != 'submit' || (!submitted &&
            submit !== false && (!submit || key == submit) && (submitted = true)))) {
          if (key in result) {
            // a key is already present; construct an array of values
            if (!|>CLASS:Object<|.isArray(result[key])) result[key] = [result[key]];
            result[key].push(value);
          }
          else result[key] = value;
        }
      }
      return result;
    });

    return options.hash ? data : |>CLASS:Object<|.toQueryString(data);
  }
};

|>CLASS:Form<|.Methods = {
  |>METHOD:serialize<|: function(form, options) {
    return |>CLASS:Form<|.serializeElements(|>CLASS:Form<|.getElements(form), options);
  },

  |>METHOD:getElements<|: function(form) {
    return $A($(form).getElementsByTagName('*')).inject([],
      function(elements, child) {
        if (|>CLASS:Form<|.Element.Serializers[child.tagName.toLowerCase()])
          elements.push(|>CLASS:Element<|.extend(child));
        return elements;
      }
    );
  },

  |>METHOD:getInputs<|: function(form, typeName, name) {
    form = $(form);
    var inputs = form.getElementsByTagName('input');

    if (!typeName && !name) return $A(inputs).map(|>CLASS:Element<|.extend);

    for (var i = 0, matchingInputs = [], length = inputs.length; i < length; i++) {
      var input = inputs[i];
      if ((typeName && input.type != typeName) || (name && input.name != name))
        continue;
      matchingInputs.push(|>CLASS:Element<|.extend(input));
    }

    return matchingInputs;
  },

  |>METHOD:disable<|: function(form) {
    form = $(form);
    |>CLASS:Form<|.getElements(form).invoke('disable');
    return form;
  },

  |>METHOD:enable<|: function(form) {
    form = $(form);
    |>CLASS:Form<|.getElements(form).invoke('enable');
    return form;
  },

  |>METHOD:findFirstElement<|: function(form) {
    var elements = $(form).getElements().findAll(function(element) {
      return 'hidden' != element.type && !element.disabled;
    });
    var firstByIndex = elements.findAll(function(element) {
      return element.hasAttribute('tabIndex') && element.tabIndex >= 0;
    }).sortBy(function(element) { return element.tabIndex }).first();

    return firstByIndex ? firstByIndex : elements.find(function(element) {
      return ['input', 'select', 'textarea'].include(element.tagName.toLowerCase());
    });
  },

  |>METHOD:focusFirstElement<|: function(form) {
    form = $(form);
    form.findFirstElement().activate();
    return form;
  },

  |>METHOD:request<|: function(form, options) {
    form = $(form), options = |>CLASS:Object<|.clone(options || { });

    var params = options.parameters, action = form.readAttribute('action') || '';
    if (action.blank()) action = |>GLOBAL:window<|.location.href;
    options.parameters = form.serialize(true);

    if (params) {
      if (|>CLASS:Object<|.isString(params)) params = params.toQueryParams();
      |>CLASS:Object<|.extend(options.parameters, params);
    }

    if (form.hasAttribute('method') && !options.method)
      options.method = form.method;

    return new |>CLASS:Ajax<|.Request(action, options);
  }
};

/*--------------------------------------------------------------------------*/

|>CLASS:Form<|.Element = {
  |>METHOD:focus<|: function(element) {
    $(element).focus();
    return element;
  },

  |>METHOD:select<|: function(element) {
    $(element).select();
    return element;
  }
};

|>CLASS:Form<|.Element.Methods = {
  |>METHOD:serialize<|: function(element) {
    element = $(element);
    if (!element.disabled && element.name) {
      var value = element.getValue();
      if (value != undefined) {
        var pair = { };
        pair[element.name] = value;
        return |>CLASS:Object<|.toQueryString(pair);
      }
    }
    return '';
  },

  |>METHOD:getValue<|: function(element) {
    element = $(element);
    var method = element.tagName.toLowerCase();
    return |>CLASS:Form<|.Element.Serializers[method](element);
  },

  |>METHOD:setValue<|: function(element, value) {
    element = $(element);
    var method = element.tagName.toLowerCase();
    |>CLASS:Form<|.Element.Serializers[method](element, value);
    return element;
  },

  |>METHOD:clear<|: function(element) {
    $(element).value = '';
    return element;
  },

  |>METHOD:present<|: function(element) {
    return $(element).value != '';
  },

  |>METHOD:activate<|: function(element) {
    element = $(element);
    try {
      element.focus();
      if (element.select && (element.tagName.toLowerCase() != 'input' ||
          !['button', 'reset', 'submit'].include(element.type)))
        element.select();
    } catch (|>UNUSED:e<|) { }
    return element;
  },

  |>METHOD:disable<|: function(element) {
    element = $(element);
    element.blur();
    element.disabled = true;
    return element;
  },

  |>METHOD:enable<|: function(element) {
    element = $(element);
    element.disabled = false;
    return element;
  }
};

/*--------------------------------------------------------------------------*/

var |>CLASS:Field<| = |>CLASS:Form<|.Element;
var |>GLOBAL:$F<| = |>CLASS:Form<|.Element.Methods.getValue;

/*--------------------------------------------------------------------------*/

|>CLASS:Form<|.Element.Serializers = {
  |>METHOD:input<|: function(element, value) {
    switch (element.type.toLowerCase()) {
      case 'checkbox':
      case 'radio':
        return |>CLASS:Form<|.Element.Serializers.inputSelector(element, value);
      default:
        return |>CLASS:Form<|.Element.Serializers.textarea(element, value);
    }
  },

  |>METHOD:inputSelector<|: function(element, value) {
    if (|>CLASS:Object<|.isUndefined(value)) return element.checked ? element.value : null;
    else element.checked = !!value;
  },

  |>METHOD:textarea<|: function(element, value) {
    if (|>CLASS:Object<|.isUndefined(value)) return element.value;
    else element.value = value;
  },

  |>METHOD:select<|: function(element, index) {
    if (|>CLASS:Object<|.isUndefined(index))
      return this[element.type == 'select-one' ?
        'selectOne' : 'selectMany'](element);
    else {
      var opt, value, single = !|>CLASS:Object<|.isArray(index);
      for (var i = 0, length = element.length; i < length; i++) {
        opt = element.options[i];
        value = this.optionValue(opt);
        if (single) {
          if (value == index) {
            opt.selected = true;
            return;
          }
        }
        else opt.selected = index.include(value);
      }
    }
  },

  |>METHOD:selectOne<|: function(element) {
    var index = element.selectedIndex;
    return index >= 0 ? this.optionValue(element.options[index]) : null;
  },

  |>METHOD:selectMany<|: function(element) {
    var values, length = element.length;
    if (!length) return null;

    for (var i = 0, values = []; i < length; i++) {
      var opt = element.options[i];
      if (opt.selected) values.push(this.optionValue(opt));
    }
    return values;
  },

  |>METHOD:optionValue<|: function(opt) {
    // extend element because hasAttribute may not be native
    return |>CLASS:Element<|.extend(opt).hasAttribute('value') ? opt.value : opt.text;
  }
};

/*--------------------------------------------------------------------------*/

|>CLASS:Abstract<|.TimedObserver = |>CLASS:Class<|.create(|>CLASS:PeriodicalExecuter<|, {
  |>METHOD:initialize<|: function($super, element, frequency, callback) {
    $super(callback, frequency);
    this.element   = $(element);
    this.lastValue = this.getValue();
  },

  |>METHOD:execute<|: function() {
    var value = this.getValue();
    if (|>CLASS:Object<|.isString(this.lastValue) && |>CLASS:Object<|.isString(value) ?
        this.lastValue != value : String(this.lastValue) != String(value)) {
      this.callback(this.element, value);
      this.lastValue = value;
    }
  }
});

|>CLASS:Form<|.Element.Observer = |>CLASS:Class<|.create(|>CLASS:Abstract<|.TimedObserver, {
  |>METHOD:getValue<|: function() {
    return |>CLASS:Form<|.Element.getValue(this.element);
  }
});

|>CLASS:Form<|.Observer = |>CLASS:Class<|.create(|>CLASS:Abstract<|.TimedObserver, {
  |>METHOD:getValue<|: function() {
    return |>CLASS:Form<|.serialize(this.element);
  }
});

/*--------------------------------------------------------------------------*/

|>CLASS:Abstract<|.EventObserver = |>CLASS:Class<|.create({
  |>METHOD:initialize<|: function(element, callback) {
    this.element  = $(element);
    this.callback = callback;

    this.lastValue = this.getValue();
    if (this.element.tagName.toLowerCase() == 'form')
      this.registerFormCallbacks();
    else
      this.registerCallback(this.element);
  },

  |>METHOD:onElementEvent<|: function() {
    var value = this.getValue();
    if (this.lastValue != value) {
      this.callback(this.element, value);
      this.lastValue = value;
    }
  },

  |>METHOD:registerFormCallbacks<|: function() {
    |>CLASS:Form<|.getElements(this.element).each(this.registerCallback, this);
  },

  |>METHOD:registerCallback<|: function(element) {
    if (element.type) {
      switch (element.type.toLowerCase()) {
        case 'checkbox':
        case 'radio':
          |>CLASS:Event<|.observe(element, 'click', this.onElementEvent.bind(this));
          break;
        default:
          |>CLASS:Event<|.observe(element, 'change', this.onElementEvent.bind(this));
          break;
      }
    }
  }
});

|>CLASS:Form<|.Element.EventObserver = |>CLASS:Class<|.create(|>CLASS:Abstract<|.EventObserver, {
  |>METHOD:getValue<|: function() {
    return |>CLASS:Form<|.Element.getValue(this.element);
  }
});

|>CLASS:Form<|.EventObserver = |>CLASS:Class<|.create(|>CLASS:Abstract<|.EventObserver, {
  |>METHOD:getValue<|: function() {
    return |>CLASS:Form<|.serialize(this.element);
  }
});
if (!|>GLOBAL:window<|.Event) var |>CLASS:Event<| = { };

|>CLASS:Object<|.extend(|>CLASS:Event<|, {
  KEY_BACKSPACE: 8,
  KEY_TAB:       9,
  KEY_RETURN:   13,
  KEY_ESC:      27,
  KEY_LEFT:     37,
  KEY_UP:       38,
  KEY_RIGHT:    39,
  KEY_DOWN:     40,
  KEY_DELETE:   46,
  KEY_HOME:     36,
  KEY_END:      35,
  KEY_PAGEUP:   33,
  KEY_PAGEDOWN: 34,
  KEY_INSERT:   45,

  cache: { },

  |>METHOD:relatedTarget<|: function(event) {
    var element;
    switch(event.type) {
      case 'mouseover': element = event.fromElement; break;
      case 'mouseout':  element = event.toElement;   break;
      default: return null;
    }
    return |>CLASS:Element<|.extend(element);
  }
});

|>CLASS:Event<|.Methods = (function() {
  var isButton;

  if (|>CLASS:Prototype<|.Browser.IE) {
    var buttonMap = { 0: 1, 1: 4, 2: 2 };
    isButton = function(event, code) {
      return event.button == buttonMap[code];
    };

  } else if (|>CLASS:Prototype<|.Browser.WebKit) {
    isButton = function(event, code) {
      switch (code) {
        case 0: return event.which == 1 && !event.metaKey;
        case 1: return event.which == 1 && event.metaKey;
        default: return false;
      }
    };

  } else {
    isButton = function(event, code) {
      return event.which ? (event.which === code + 1) : (event.button === code);
    };
  }

  return {
    |>METHOD:isLeftClick<|:   function(event) { return isButton(event, 0) },
    |>METHOD:isMiddleClick<|: function(event) { return isButton(event, 1) },
    |>METHOD:isRightClick<|:  function(event) { return isButton(event, 2) },

    |>METHOD:element<|: function(event) {
      var node = |>CLASS:Event<|.extend(event).target;
      return |>CLASS:Element<|.extend(node.nodeType == |>CLASS:Node<|.TEXT_NODE ? node.parentNode : node);
    },

    |>METHOD:findElement<|: function(event, expression) {
      var element = |>CLASS:Event<|.element(event);
      if (!expression) return element;
      var elements = [element].concat(element.ancestors());
      return |>CLASS:Selector<|.findElement(elements, expression, 0);
    },

    |>METHOD:pointer<|: function(event) {
      return {
        x: event.pageX || (event.clientX +
          (|>GLOBAL:document<|.documentElement.scrollLeft || |>GLOBAL:document<|.body.scrollLeft)),
        y: event.pageY || (event.clientY +
          (|>GLOBAL:document<|.documentElement.scrollTop || |>GLOBAL:document<|.body.scrollTop))
      };
    },

    |>METHOD:pointerX<|: function(event) { return |>CLASS:Event<|.pointer(event).x },
    |>METHOD:pointerY<|: function(event) { return |>CLASS:Event<|.pointer(event).y },

    |>METHOD:stop<|: function(event) {
      |>CLASS:Event<|.extend(event);
      event.preventDefault();
      event.stopPropagation();
      event.stopped = true;
    }
  };
})();

|>CLASS:Event<|.extend = (function() {
  var methods = |>CLASS:Object<|.keys(|>CLASS:Event<|.Methods).inject({ }, function(m, name) {
    m[name] = |>CLASS:Event<|.Methods[name].methodize();
    return m;
  });

  if (|>CLASS:Prototype<|.Browser.IE) {
    |>CLASS:Object<|.extend(methods, {
      |>METHOD:stopPropagation<|: function() { this.cancelBubble = true },
      |>METHOD:preventDefault<|:  function() { this.returnValue = false },
      |>METHOD:inspect<|: function() { return "[object Event]" }
    });

    return function(event) {
      if (!event) return false;
      if (event._extendedByPrototype) return event;

      event._extendedByPrototype = |>CLASS:Prototype<|.emptyFunction;
      var pointer = |>CLASS:Event<|.pointer(event);
      |>CLASS:Object<|.extend(event, {
        target: event.srcElement,
        relatedTarget: |>CLASS:Event<|.relatedTarget(event),
        pageX:  pointer.x,
        pageY:  pointer.y
      });
      return |>CLASS:Object<|.extend(event, methods);
    };

  } else {
    |>CLASS:Event<|.prototype = |>CLASS:Event<|.prototype || |>GLOBAL:document<|.createEvent("HTMLEvents").__proto__;
    |>CLASS:Object<|.extend(|>CLASS:Event<|.prototype, methods);
    return |>CLASS:Prototype<|.K;
  }
})();

|>CLASS:Object<|.extend(|>CLASS:Event<|, (function() {
  var cache = |>CLASS:Event<|.cache;

  function |>METHOD:getEventID<|(element) {
    if (element._eventID) return element._eventID;
    arguments.callee.id = arguments.callee.id || 1;
    return element._eventID = ++arguments.callee.id;
  }

  function |>METHOD:getDOMEventName<|(eventName) {
    if (eventName && eventName.include(':')) return "dataavailable";
    return eventName;
  }

  function |>METHOD:getCacheForID<|(id) {
    return cache[id] = cache[id] || { };
  }

  function |>METHOD:getWrappersForEventName<|(id, eventName) {
    var c = getCacheForID(id);
    return c[eventName] = c[eventName] || [];
  }

  function |>METHOD:createWrapper<|(element, eventName, handler) {
    var id = getEventID(element);
    var c = getWrappersForEventName(id, eventName);
    if (c.pluck("handler").include(handler)) return false;

    var wrapper = function(event) {
      if (!|>CLASS:Event<| || !|>CLASS:Event<|.extend ||
        (event.eventName && event.eventName != eventName))
          return false;

      |>CLASS:Event<|.extend(event);
      handler.call(element, event)
    };

    wrapper.handler = handler;
    c.push(wrapper);
    return wrapper;
  }

  function |>METHOD:findWrapper<|(id, eventName, handler) {
    var c = getWrappersForEventName(id, eventName);
    return c.find(function(wrapper) { return wrapper.handler == handler });
  }

  function |>METHOD:destroyWrapper<|(id, eventName, handler) {
    var c = getCacheForID(id);
    if (!c[eventName]) return false;
    c[eventName] = c[eventName].without(findWrapper(id, eventName, handler));
  }

  function |>METHOD:destroyCache<|() {
    for (var id in cache)
      for (var eventName in cache[id])
        cache[id][eventName] = null;
  }

  if (|>GLOBAL:window<|.attachEvent) {
    |>GLOBAL:window<|.attachEvent("onunload", |>GLOBAL:destroyCache<|);
  }

  return {
    |>METHOD:observe<|: function(element, eventName, handler) {
      element = $(element);
      var name = getDOMEventName(eventName);

      var wrapper = createWrapper(element, eventName, handler);
      if (!wrapper) return element;

      if (element.addEventListener) {
        element.addEventListener(name, wrapper, false);
      } else {
        element.attachEvent("on" + name, wrapper);
      }

      return element;
    },

    |>METHOD:stopObserving<|: function(element, eventName, handler) {
      element = $(element);
      var id = getEventID(element), name = getDOMEventName(eventName);

      if (!handler && eventName) {
        getWrappersForEventName(id, eventName).each(function(wrapper) {
          element.stopObserving(eventName, wrapper.handler);
        });
        return element;

      } else if (!eventName) {
        |>CLASS:Object<|.keys(getCacheForID(id)).each(function(eventName) {
          element.stopObserving(eventName);
        });
        return element;
      }

      var wrapper = findWrapper(id, eventName, handler);
      if (!wrapper) return element;

      if (element.removeEventListener) {
        element.removeEventListener(name, wrapper, false);
      } else {
        element.detachEvent("on" + name, wrapper);
      }

      destroyWrapper(id, eventName, handler);

      return element;
    },

    |>METHOD:fire<|: function(element, eventName, memo) {
      element = $(element);
      if (element == |>GLOBAL:document<| && |>GLOBAL:document<|.createEvent && !element.dispatchEvent)
        element = |>GLOBAL:document<|.documentElement;

      if (|>GLOBAL:document<|.createEvent) {
        var event = |>GLOBAL:document<|.createEvent("HTMLEvents");
        event.initEvent("dataavailable", true, true);
      } else {
        var event = |>GLOBAL:document<|.createEventObject();
        event.eventType = "ondataavailable";
      }

      event.eventName = eventName;
      event.memo = memo || { };

      if (|>GLOBAL:document<|.createEvent) {
        element.dispatchEvent(event);
      } else {
        element.fireEvent(event.eventType, event);
      }

      return |>CLASS:Event<|.extend(event);
    }
  };
})());

|>CLASS:Object<|.extend(|>CLASS:Event<|, |>CLASS:Event<|.Methods);

|>CLASS:Element<|.addMethods({
  fire:          |>CLASS:Event<|.fire,
  observe:       |>CLASS:Event<|.observe,
  stopObserving: |>CLASS:Event<|.stopObserving
});

|>CLASS:Object<|.extend(|>GLOBAL:document<|, {
  fire:          |>CLASS:Element<|.Methods.fire.methodize(),
  observe:       |>CLASS:Element<|.Methods.observe.methodize(),
  stopObserving: |>CLASS:Element<|.Methods.stopObserving.methodize()
});

(function() {
  /* Support for the DOMContentLoaded event is based on work by Dan Webb,
     Matthias Miller, Dean Edwards and John Resig. */

  var timer, fired = false;

  function |>METHOD:fireContentLoadedEvent<|() {
    if (fired) return;
    if (timer) |>GLOBAL:window<|.clearInterval(timer);
    |>GLOBAL:document<|.fire("dom:loaded");
    fired = true;
  }

  if (|>GLOBAL:document<|.addEventListener) {
    if (|>CLASS:Prototype<|.Browser.WebKit) {
      timer = |>GLOBAL:window<|.setInterval(function() {
        if (|>REGEXP:/loaded|complete/<|.test(|>GLOBAL:document<|.readyState))
          fireContentLoadedEvent();
      }, 0);

      |>CLASS:Event<|.observe(|>GLOBAL:window<|, "load", |>GLOBAL:fireContentLoadedEvent<|);

    } else {
      |>GLOBAL:document<|.addEventListener("DOMContentLoaded",
        |>GLOBAL:fireContentLoadedEvent<|, false);
    }

  } else {
    |>GLOBAL:document<|.write("<script id=__onDOMContentLoaded defer src=//:><\/script>");
    $("__onDOMContentLoaded").onreadystatechange = function() {
      if (this.readyState == "complete") {
        this.onreadystatechange = null;
        fireContentLoadedEvent();
      }
    };
  }
})();
/*------------------------------- DEPRECATED -------------------------------*/

|>CLASS:Hash<|.toQueryString = |>CLASS:Object<|.toQueryString;

var |>CLASS:Toggle<| = { display: |>CLASS:Element<|.toggle };

|>CLASS:Element<|.Methods.childOf = |>CLASS:Element<|.Methods.descendantOf;

var |>CLASS:Insertion<| = {
  |>METHOD:Before<|: function(element, content) {
    return |>CLASS:Element<|.insert(element, {before:content});
  },

  |>METHOD:Top<|: function(element, content) {
    return |>CLASS:Element<|.insert(element, {top:content});
  },

  |>METHOD:Bottom<|: function(element, content) {
    return |>CLASS:Element<|.insert(element, {bottom:content});
  },

  |>METHOD:After<|: function(element, content) {
    return |>CLASS:Element<|.insert(element, {after:content});
  }
};

var |>GLOBAL:$continue<| = new |>CLASS:Error<|('"throw $continue" is deprecated, use "return" instead');

// This should be moved to script.aculo.us; notice the deprecated methods
// further below, that map to the newer Element methods.
var |>CLASS:Position<| = {
  // set to true if needed, warning: firefox performance problems
  // NOT neeeded for page scrolling, only if draggable contained in
  // scrollable elements
  includeScrollOffsets: false,

  // must be called before calling withinIncludingScrolloffset, every time the
  // page is scrolled
  |>METHOD:prepare<|: function() {
    this.deltaX =  |>GLOBAL:window<|.pageXOffset
                || |>GLOBAL:document<|.documentElement.scrollLeft
                || |>GLOBAL:document<|.body.scrollLeft
                || 0;
    this.deltaY =  |>GLOBAL:window<|.pageYOffset
                || |>GLOBAL:document<|.documentElement.scrollTop
                || |>GLOBAL:document<|.body.scrollTop
                || 0;
  },

  // caches x/y coordinate pair to use with overlap
  |>METHOD:within<|: function(element, x, y) {
    if (this.includeScrollOffsets)
      return this.withinIncludingScrolloffsets(element, x, y);
    this.xcomp = x;
    this.ycomp = y;
    this.offset = |>CLASS:Element<|.cumulativeOffset(element);

    return (y >= this.offset[1] &&
            y <  this.offset[1] + element.offsetHeight &&
            x >= this.offset[0] &&
            x <  this.offset[0] + element.offsetWidth);
  },

  |>METHOD:withinIncludingScrolloffsets<|: function(element, x, y) {
    var offsetcache = |>CLASS:Element<|.cumulativeScrollOffset(element);

    this.xcomp = x + offsetcache[0] - this.deltaX;
    this.ycomp = y + offsetcache[1] - this.deltaY;
    this.offset = |>CLASS:Element<|.cumulativeOffset(element);

    return (this.ycomp >= this.offset[1] &&
            this.ycomp <  this.offset[1] + element.offsetHeight &&
            this.xcomp >= this.offset[0] &&
            this.xcomp <  this.offset[0] + element.offsetWidth);
  },

  // within must be called directly before
  |>METHOD:overlap<|: function(mode, element) {
    if (!mode) return 0;
    if (mode == 'vertical')
      return ((this.offset[1] + element.offsetHeight) - this.ycomp) /
        element.offsetHeight;
    if (mode == 'horizontal')
      return ((this.offset[0] + element.offsetWidth) - this.xcomp) /
        element.offsetWidth;
  },

  // Deprecation layer -- use newer Element methods now (1.5.2).

  cumulativeOffset: |>CLASS:Element<|.Methods.cumulativeOffset,

  positionedOffset: |>CLASS:Element<|.Methods.positionedOffset,

  |>METHOD:absolutize<|: function(element) {
    |>CLASS:Position<|.prepare();
    return |>CLASS:Element<|.absolutize(element);
  },

  |>METHOD:relativize<|: function(element) {
    |>CLASS:Position<|.prepare();
    return |>CLASS:Element<|.relativize(element);
  },

  realOffset: |>CLASS:Element<|.Methods.cumulativeScrollOffset,

  offsetParent: |>CLASS:Element<|.Methods.getOffsetParent,

  page: |>CLASS:Element<|.Methods.viewportOffset,

  |>METHOD:clone<|: function(source, target, options) {
    options = options || { };
    return |>CLASS:Element<|.clonePosition(target, source, options);
  }
};

/*--------------------------------------------------------------------------*/

if (!|>GLOBAL:document<|.getElementsByClassName) |>GLOBAL:document<|.getElementsByClassName = function(instanceMethods){
  function |>METHOD:iter<|(name) {
    return name.blank() ? null : "[contains(concat(' ', @class, ' '), ' " + name + " ')]";
  }

  instanceMethods.getElementsByClassName = |>CLASS:Prototype<|.BrowserFeatures.XPath ?
  function(element, className) {
    className = className.toString().strip();
    var cond = |>REGEXP:/\s/<|.test(className) ? $w(className).map(|>GLOBAL:iter<|).join('') : |>GLOBAL:iter<|(className);
    return cond ? |>GLOBAL:document<|._getElementsByXPath('.//*' + cond, element) : [];
  } : function(element, className) {
    className = className.toString().strip();
    var elements = [], classNames = (|>REGEXP:/\s/<|.test(className) ? $w(className) : null);
    if (!classNames && !className) return elements;

    var nodes = $(element).getElementsByTagName('*');
    className = ' ' + className + ' ';

    for (var i = 0, child, cn; child = nodes[i]; i++) {
      if (child.className && (cn = ' ' + child.className + ' ') && (cn.include(className) ||
          (classNames && classNames.all(function(name) {
            return !name.toString().blank() && cn.include(' ' + name + ' ');
          }))))
        elements.push(|>CLASS:Element<|.extend(child));
    }
    return elements;
  };

  return function(className, parentElement) {
    return $(parentElement || |>GLOBAL:document<|.body).getElementsByClassName(className);
  };
}(|>CLASS:Element<|.Methods);

/*--------------------------------------------------------------------------*/

|>CLASS:Element<|.ClassNames = |>CLASS:Class<|.create();
|>CLASS:Element<|.ClassNames.prototype = {
  |>METHOD:initialize<|: function(element) {
    this.element = $(element);
  },

  |>METHOD:_each<|: function(iterator) {
    this.element.className.split(|>REGEXP:/\s+/<|).select(function(name) {
      return name.length > 0;
    })._each(iterator);
  },

  |>METHOD:set<|: function(className) {
    this.element.className = className;
  },

  |>METHOD:add<|: function(classNameToAdd) {
    if (this.include(classNameToAdd)) return;
    this.set($A(this).concat(classNameToAdd).join(' '));
  },

  |>METHOD:remove<|: function(classNameToRemove) {
    if (!this.include(classNameToRemove)) return;
    this.set($A(this).without(classNameToRemove).join(' '));
  },

  |>METHOD:toString<|: function() {
    return $A(this).join(' ');
  }
};

|>CLASS:Object<|.extend(|>CLASS:Element<|.ClassNames.prototype, |>CLASS:Enumerable<|);

/*--------------------------------------------------------------------------*/

|>CLASS:Element<|.addMethods();
